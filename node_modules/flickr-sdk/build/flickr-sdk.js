/**
 * Modules in this bundle
 * @license
 *
 * flickr-sdk:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Jim Whimpey <whimpey@flickr.com>
 *   version: 2.1.0
 *
 * backo:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   maintainers: tjholowaychuk <tj@vision-media.ca>, segment <tj@segment.io>
 *   homepage: https://github.com/segmentio/backo
 *   version: 1.1.0
 *
 * browserify:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: James Halliday <mail@substack.net>
 *   maintainers: substack <substack@gmail.com>, maxogden <max@maxogden.com>, mafintosh <mathiasbuus@gmail.com>, domenic <d@domenic.me>, dominictarr <dominic.tarr@gmail.com>, terinjokes <terinjokes@gmail.com>, feross <feross@feross.org>, jmm <npm-public@jessemccarthy.net>, thlorenz <thlorenz@gmx.de>, zertosh <zertosh@gmail.com>
 *   homepage: https://github.com/substack/node-browserify#readme
 *   version: 11.1.0
 *
 * component-emitter:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   maintainers: tootallnate <nathan@tootallnate.net>, hughsk <hughskennedy@gmail.com>, trevorgerhardt <trevorgerhardt@gmail.com>, timaschew <timaschew@gmail.com>, tjholowaychuk <tj@vision-media.ca>, rauchg <rauchg@gmail.com>, retrofox <rdsuarez@gmail.com>, coreh <thecoreh@gmail.com>, forbeslindesay <forbes@lindesay.co.uk>, kelonye <kelonyemitchel@gmail.com>, mattmueller <mattmuelle@gmail.com>, yields <yields@icloud.com>, anthonyshort <antshort@gmail.com>, jongleberry <jonathanrichardong@gmail.com>, ianstormtaylor <ian@ianstormtaylor.com>, cristiandouce <cristian@gravityonmars.com>, swatinem <arpad.borsos@googlemail.com>, stagas <gstagas@gmail.com>, amasad <amjad.masad@gmail.com>, juliangruber <julian@juliangruber.com>, calvinfo <calvin@calv.info>, dominicbarnes <dominic@dbarnes.info>, blakeembrey <hello@blakeembrey.com>, timoxley <secoif@gmail.com>, jonathanong <jonathanrichardong@gmail.com>, queckezz <fabian.eichenberger@gmail.com>, nami-doc <vendethiel@hotmail.fr>, clintwood <clint@anotherway.co.za>, thehydroimpulse <dnfagnan@gmail.com>, stephenmathieson <me@stephenmathieson.com>, dfcreative <df.creative@gmail.com>, defunctzombie <shtylman@gmail.com>
 *   homepage: https://github.com/component/emitter#readme
 *   version: 1.2.1
 *
 * deepmerge:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Nick Fisher
 *   maintainers: nfisher <nfisher@trafficland.com>, kylemathews <mathews.kyle@gmail.com>
 *   homepage: https://github.com/nrf110/deepmerge
 *   version: 0.2.10
 *
 * except:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Martin Andert <mandert@gmail.com>
 *   maintainers: martinandert <mandert@gmail.com>
 *   homepage: https://github.com/martinandert/except
 *   version: 0.1.3
 *
 * flickr-api-swagger:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Jim Whimpey
 *   maintainers: alex-seville <hi@alexanderseville.com>, jeremyruppel <jeremy.ruppel@gmail.com>, superic <eric.willis@gmail.com>
 *   version: 2.7.0
 *
 * indexof:
 *   maintainers: tjholowaychuk <tj@vision-media.ca>
 *   version: 0.0.1
 *
 * native-promise-only:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Kyle Simpson <getify@gmail.com>
 *   maintainers: getify <getify@gmail.com>
 *   homepage: http://github.com/getify/native-promise-only
 *   version: 0.8.1
 *
 * reduce-component:
 *   license: Apache, Version 2.0
 *   maintainers: gjohnson <gjj391@gmail.com>
 *   version: 1.0.1
 *
 * superagent:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: TJ Holowaychuk <tj@vision-media.ca>
 *   maintainers: defunctzombie <shtylman@gmail.com>, kof <oleg008@gmail.com>, kornel <pornel@pornel.net>, naman34 <naman34@gmail.com>, nw <nw@nwhite.net>, rauchg <rauchg@gmail.com>, superjoe <superjoe30@gmail.com>, tjholowaychuk <tj@vision-media.ca>, travisjeffery <tj@travisjeffery.com>, yields <yields@icloud.com>
 *   contributors: Kornel Lesi≈Ñski <kornel@geekhood.net>, Peter Lyons <pete@peterlyons.com>, Hunter Loftis <hunter@hunterloftis.com>
 *   homepage: https://github.com/visionmedia/superagent#readme
 *   version: 1.8.3
 *
 * This header is generated by licensify (https://github.com/twada/licensify)
 */
require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright 2016 Yahoo Inc.
// Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.

/**
 * This method looks up the API definition in `schema` by the
 * arbitrary identifier `operationId`. Returns an object of the
 * holding `{ schema, path, verb }`, where `path` is the path key
 * of the operation and `verb` is the HTTP verb to use. Throws
 * if no operation exists in the schema by that ID.
 * @param {Object} schema The swagger schema to walk
 * @param {String} operationId The operation ID to find
 * @returns {Array}
 */
module.exports = function (schema, operationId) {

	var path;
	var verb;

	for (path in schema.paths) {
		/* istanbul ignore next */
		if (!schema.paths.hasOwnProperty(path)) {
			continue;
		}
		for (verb in schema.paths[path]) {
			/* istanbul ignore next */
			if (!schema.paths[path].hasOwnProperty(verb)) {
				continue;
			}
			if (schema.paths[path][verb].operationId === operationId) {
				return {
					schema: schema,
					path: path,
					verb: verb
				};
			}
		}
	}

	throw new Error('Unsupported operation: ' + operationId + ' (' + schema.info.version + ')');
};

},{}],2:[function(require,module,exports){
(function (process){
// Copyright 2016 Yahoo Inc.
// Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.

/* jshint ignore:start */
/* jscs:disable */
var Promise = require('native-promise-only');
var request = require('superagent');
var except = require('except');
var Backoff = require('backo');
var backoff = new Backoff({ min: 100, max: 10000, jitter: 0, factor: 2 });
var retryErrors = require('./retryerrors.js');
var merge = require('deepmerge');
var validate = require('./validate.js');
var generateURL = require('./generate-url.js');
var headers = require('./headers.js');

// Different crypto for client vs. server
/* istanbul ignore next */
var crypto = process.browser ? require('../shims/crypto-client') : require('../shims/crypto-server');

/**
 * Initiate the Transport function
 *
 * @method FlickrTransport
 * @param {Object} config - Any options that you wish to configure when setting up the API.
 * @returns {Function} - The function to which the other calls can be chained.
 */
var FlickrTransport = function (config, options) {

	if (!config.timeout) {
		config.timeout = 15000; // 15 seconds
	}

	if (!config.retries) {
		config.retries = 3;
	}

	if (!config.onProgress) {
		/* istanbul ignore next */
		config.onProgress = function () { /*noop*/ };
	}

	this.config = config;
	this.retries = 3;
	this.plugins = [];

	this.log = function (message) {
		if (options && options.logger && typeof options.logger.log === 'function') {
			options.logger.log(message);
		}
	};

};

/**
 * Create an oauth 1.0 signature from the request object
 * I would love to use the oauth-signature npm module here
 * but because of the upload API's requirement to *not* include
 * the access token secret in the signing key we can't use it.
 *
 * @method createSignature
 * @param {Object} req - The request object.
 * @param {Object} params - The params being sent through to the call.
 * @returns {string} - The signature required to make the request.
 */
FlickrTransport.prototype.createSignature = function (req, params, signingSecret) {

	var baseString = req.method.toUpperCase() + '&' + encodeURIComponent(req.url) + '&',
	    signingKey = this.config.apiSecret + "&" + (signingSecret || '');

	Object.keys(params).sort().forEach(function(key, i) {
		baseString += (i > 0) ? encodeURIComponent('&') : '';
		baseString += encodeURIComponent(key + '=' + params[key]);
	});

	return crypto.createHmac('sha1', signingKey).update(baseString).digest('base64');

};

/**
 * Create a one-time nonce
 *
 * @method createNonce
 * @returns {string} - The hash required to make the request.
 */
FlickrTransport.prototype.createNonce = function () {
	return crypto.createHash('sha1').update(String(Date.now())).digest('hex');
};

/**
 * Determine if the error/response from the api call means we should try and make the call again.
 *
 * @method shouldRetry
 * @param {Object} error - The error object. This can also be null if there is no error.
 * @param {Object} response - The response object.
 * @returns {Boolean} - Whether or not the call should retry.
 */
FlickrTransport.prototype.shouldRetry = function (error, response) {
	return retryErrors.some(function (check) {
		return check(error, response);
	});
}

/**
 * Superagent plugin for all of the default flickr api v1 params
 *
 * @method createSignature
 * @returns {Object} The default params.
 */
FlickrTransport.prototype.defaults = function (req) {
	return {
		format: 'json',
		nojsoncallback: 1
	};
};

/**
 * Attaching plugins to the request
 *
 * @method usePlugins
 */
FlickrTransport.prototype.usePlugins = function (plugins) {

	return function (req) {
		// If there's plugins use them
		if (plugins.length > 0) {
			plugins.forEach(function (plugin) {
				req.use(plugin);
			});
		}
	}

};

/**
 * Superagent plugin attaching a file if we've got one
 *
 * @method attachFile
 * @param {Object} params - Contains the parameters being passed to the api.
 * @returns {Function} - A callable function that takes the request as a parameter.
 */
FlickrTransport.prototype.attachFile = function (params) {
	return function (req) {
		if (params.photo) {
			req.attach('photo', params.photo);
		}
	};
};

/**
 * Superagent plugin for generating oauth params
 *
 * @method oAuth
 * @param {Object} params - Contains the parameters being passed to the api.
 * @returns {Function} - A callable function that takes the request as a parameter.
 */
FlickrTransport.prototype.oAuth = function (params, auth, isUpload) {

	var flickrTransport = this;

	return function (req) {

		if (isUpload) {

			// Flickr upload params get appended to the POST body
			var oauthParams = {
				oauth_consumer_key:     flickrTransport.config.apiKey,
				oauth_token:            auth.accessToken,
				oauth_version:          '1.0',
				oauth_timestamp:        Math.round(Date.now() / 1000),
				oauth_nonce:            flickrTransport.createNonce(),
				oauth_signature_method: 'HMAC-SHA1'
			};

			oauthParams = merge(oauthParams, flickrTransport.defaults(req));

			Object.keys(oauthParams).forEach(function (oauthParam) {
				if (typeof oauthParams[oauthParam] !== 'undefined') {
					req.field(oauthParam, oauthParams[oauthParam]);
				}
			});

			req.field('oauth_signature', flickrTransport.createSignature(req, merge(params, oauthParams), auth.accessTokenSecret));

		} else {

			var oauthParams = {
				oauth_consumer_key: flickrTransport.config.apiKey,
				oauth_token:        auth.accessToken,
				oauth_version:      '1.0',
				oauth_timestamp:    Math.round(Date.now() / 1000),
				oauth_nonce: flickrTransport.createNonce(),
				oauth_signature_method: 'HMAC-SHA1'
			};

			oauthParams = merge(oauthParams, flickrTransport.defaults(req));

			req.query(oauthParams);

			req.query({
				oauth_signature: flickrTransport.createSignature(req, merge(params, oauthParams), auth.accessTokenSecret)
			});

		}

	}

};

/**
 * Calls the given operation with `params`. The object provided
 * is in the form `{ schema, path, verb }`. Throws if the params
 * do not match the operation's parameters.
 * @private
 * @param {Object} additionalParams Hash of extra params to merge in
 * @param {Object} transportConfig Hash of extra transport configs to merge in
 * @returns {Promise}
 */
FlickrTransport.prototype.call = function (definition, params, auth, additionalParams, transportConfig) {
	var flickrTransport = this;

	/* istanbul ignore next */
	if (process.browser && flickrTransport.config && flickrTransport.config.apiSecret) {
		throw new Error('Embedding your API secret in the browser could allow a malicious third-party to make API calls using your key.  Making authenticated API calls is disabled in the browser using this SDK at the moment.');
	}

	var schema = definition.schema;
	var path = definition.path;
	var verb = definition.verb;
	var config = schema.paths[path][verb];
	var operationId = config.operationId;
	var startTime = new Date().getTime();
	var defaultParamExceptions = [ 'photo', 'url', 'arguments', 'headers' ];
	var nonQueryParams = [];
	var responseHeaders = {};
	var responseBody;

	auth = auth || {};

	var apiParams = merge(params, additionalParams || {});

	// Remove any null params
	Object.keys(apiParams).forEach(function (paramKey) {
		if (apiParams[paramKey] === null) {
			delete apiParams[paramKey];
		}
	});

	return new Promise(function (resolve, reject) {

		var validationErrors = validate(apiParams, config.parameters);

		if (validationErrors.length > 0) {
			reject(validationErrors);
			return;
		}

		// Get a URL with params substituted in where appropriate
		var uri = generateURL(definition, apiParams, merge(flickrTransport.config, transportConfig || {}));

		// Filter out non-query params
		config.parameters.forEach(function (configParam) {
			if (configParam.in !== 'query') {
				nonQueryParams.push(configParam.name);
			}
		});

		// Not all params get passed to oauth
		var oauthParams = except(apiParams, defaultParamExceptions.concat(nonQueryParams));

		// Start log
		flickrTransport.log("Starting " + verb + " API call to " + uri);

		function makeRequest() {

			request(verb, uri)
			.use(function (request) {
				/* istanbul ignore else */
				if (!process.browser) {
					// Cookies are implicit on the client
					request.set("Cookie", flickrTransport.config.cookie || "");
				}
				return request;
			})
			.use(function (request) {
				request.query(oauthParams);

				if (verb === "post") { request.send(apiParams); }

				return request;
			})
			.use(flickrTransport.attachFile(apiParams))
			.use(function (request) {
				// if we don't have an access token, don't attach auth
				// to the request
				if (operationId !== 'getRequestToken' && operationId !== 'getAccessToken') {
					return flickrTransport.oAuth(oauthParams, auth, apiParams.photo)(request);
				}
				return request;
			})
			.use(flickrTransport.usePlugins(flickrTransport.plugins))
			.end(handleRequest);

			// Reset the plugins as they are definied per request
			flickrTransport.plugins = [];
		}

		function handleRequest(err, res) {

			// End log
			flickrTransport.log("Finished " + verb + " API call to " + uri + " in " + (new Date().getTime() - startTime) + "ms");

			// Decrement retries
			flickrTransport.retries--;

			if (err) {
				// HTTP error
				if (flickrTransport.retries > 0 && flickrTransport.shouldRetry(err, res)) {
					// Try again
					setTimeout(makeRequest, backoff.duration());
				} else {
					flickrTransport.resetRetries();
					reject(err);
					return;
				}
			} else {

				if (res.body && Object.keys(res.body).length === 0 && res.text.match(/xml/)) {
					// Deal with the XML response as if it's a string. The response
					// is always simple so there's no need to convert it wholesale to
					// JSON which would introduce a heavy dependency.
					/* istanbul ignore next */
					if (res.text.match(/stat="fail"/)) {
						// Good ol' Flickr 200 but with error
						flickrTransport.resetRetries();
						reject({
							code: res.text.match(/code="([0-9]+)"/)[1],
							message: res.text.match(/msg="([A-Za-z0-9\-\s]+)"/)[1]
						});
						return;
					} else {
						flickrTransport.resetRetries();
						responseBody = {
							photoID: res.text.match(/<photoid>([0-9]+)<\/photoid>/)[1]
						};
					}
				} else {
					// Regular response in the body
					if (res.body && res.body.stat === 'fail') {
						// Good ol' Flickr 200 but with error
						flickrTransport.resetRetries();
						reject(res.body);
						return;
					} else {
						flickrTransport.resetRetries();
						responseBody = res.body;
					}
				}

				// Check if there are response headers we want to return
				// in our own response
				Object.keys(res.headers).forEach(function (headerKey) {
					if (headers[headerKey]) {
						responseHeaders[headers[headerKey]] = res.headers[headerKey];
					}
				});

				responseBody = responseBody || {};

				// When we're requesting a token, it returns text that we need to parse
				/* istanbul ignore next */
				if (res.type === 'text/plain' && (operationId === "getRequestToken" || operationId === "getAccessToken")) {
					var values = (res.text || '').split('&');
					values.forEach(function (keyPair) {
						var keyVal = keyPair.split('=');
						if (keyVal.length > 1) {
							responseBody[keyVal[0]] = keyVal[1];
						}
					})
				}

				// Return the whole lot
				resolve({
					headers: responseHeaders,
					body: responseBody
				});

			}

		}

		// Make the initial call
		makeRequest();

	});

};

/**
 * Resets the backoff and retries remaining counter
 * @private
 */
FlickrTransport.prototype.resetRetries = function () {
	backoff.reset();
	this.retries = 3;
};

module.exports = FlickrTransport;

}).call(this,require('_process'))
},{"../shims/crypto-client":28,"../shims/crypto-server":29,"./generate-url.js":3,"./headers.js":4,"./retryerrors.js":5,"./validate.js":13,"_process":15,"backo":14,"deepmerge":16,"except":17,"native-promise-only":21,"superagent":22}],3:[function(require,module,exports){
// Copyright 2016 Yahoo Inc.
// Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.

var join = require('path').join;

/**
 * Takes the API definition + the params passed in at run time
 * to generate a URL with subbed in params
 * @param {Object} defintion The swagger definition for this operation
 * @param {Object} params All the params passed in by the user
 * @param {Object} transportConfig Flickr transport config with potential host and basePath overrides
 * @returns {String} the full path
 */
module.exports = function (definition, params, transportConfig) {

	var schema = definition.schema;
	var path   = definition.path;
	var verb   = definition.verb;
	var config = schema.paths[path][verb];
	var http   = 'https';

	// Allow overridng a host and basePath
	var host = (transportConfig && transportConfig.host) ? transportConfig.host : schema.host;
	var basePath = (transportConfig && transportConfig.basePath) ? transportConfig.basePath : schema.basePath || '';

	// If there's a scheme defined, use it
	if (schema.schemes && schema.schemes[0]) {
		http = schema.schemes[0];
	}

	// If there's an override scheme, use that
	if (transportConfig && transportConfig.scheme) {
		http = transportConfig.scheme;
	}

	// Loop through params that are in the URL
	if (config && config.parameters) {
		config.parameters.forEach(function (paramConfig) {
			// If this param should be in the path and its value has been passed in
			if (paramConfig.in === 'path' && typeof params[paramConfig.name] !== 'undefined') {
				// Replace the place holder with the value
				path = path.replace('{' + paramConfig.name + '}', params[paramConfig.name]);
			}
		});
	}

	// Remove any path params that haven't been substituted
	path = path.replace(/\/{[a-zA-Z_]+}/, '');

	return http + '://' + host + join(basePath, path);

};

},{"path":15}],4:[function(require,module,exports){
// Copyright 2016 Yahoo Inc.
// Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.

// Which header fields do we want to pass to the client
// and what do we want to name them?
module.exports = {
	'x-total-count': 'totalCount',
	'link': 'link',
	'etag': 'etag'
};


},{}],5:[function(require,module,exports){
/**
 * The following is borrowed from the the superagent-retry repo.
 * We don't need to use the entire repo, only the list of possible errors.
 * https://github.com/segmentio/superagent-retry
 *
 * (The MIT License)
 *
 * Copyright (c) 2013 Segmentio <friends@segment.io>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * Connection reset detection
 */

function econnreset(err, res) {
	return err && err.code === 'ECONNRESET';
}


/**
 * Timeout detection
 */

function etimedout(err, res) {
	return err && err.code === 'ETIMEDOUT';
}


/**
 * Can't get address info
 */

function eaddrinfo(err, res) {
	return err && err.code === 'EADDRINFO';
}


/**
 * Socket timeout detection
 */

function esockettimedout(err, res) {
	return err && err.code === 'ESOCKETTIMEDOUT';
}


/**
 * Bad gateway error detection
 */

function gateway(err, res) {
	return res && [502,503,504].indexOf(res.status) !== -1;
}


/**
 * Superagent timeout errors
 */

function timeout(err, res) {
	return err && /^timeout of \d+ms exceeded$/.test(err.message);
}

module.exports = [
	econnreset,
	etimedout,
	eaddrinfo,
	esockettimedout,
	gateway,
	timeout
];

},{}],6:[function(require,module,exports){
/**
 * Group of methods for working with albums
 * @memberof! FlickrRequest#
 * @function albums
 * @param {string=} albumID - ID of the album we're working with
 * @returns {object} verbs for working with a album and child namespaces
 */

var apiV1 = require('flickr-api-swagger');

module.exports = function (albumID) {

	var request = this;

	return {

		/**
		 * Group of methods for working with media in albums
		 * @memberof! FlickrRequest#
		 * @function albums.media
		 * @returns {object} verbs for working with a album and child namespaces
		 */
		media: function () {

			return {

				/**
				 * Gets photos from an album
				 * @memberof! FlickrRequest#
				 * @function albums.media.get
				 * @param {object} additionalParams - extra data to attach to the API call
				 * @returns {object} an existing group object
				 */
				get: function (additionalParams) {
					return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getAlbumByID'), { "photoset_id": albumID }, request.auth, additionalParams);
				}

			};

		}

	};

};
},{"flickr-api-swagger":20}],7:[function(require,module,exports){
(function (process){
/**
 * Group of methods for authenticating with the Flickr API
 * @memberof! FlickrRequest#
 * @function auth
 * @returns {object} verbs for working with auth namespace
 */

var apiV1 = require('flickr-api-swagger');
var generateURL = require('../generate-url.js');

function getRequestToken (request, oauthCallback) {
	var oauthParams = {
			oauth_nonce: request.sdk.transport.createNonce(),
			oauth_timestamp: '' + Math.round(Date.now() / 1000),
			oauth_signature_method: 'HMAC-SHA1',
			oauth_version: '1.0',
			oauth_consumer_key: request.sdk.transport.config.apiKey,
			oauth_callback: encodeURIComponent(oauthCallback)
		},
		decoratedRequest = request,
		definition = request.sdk.findDefinition(apiV1, 'getRequestToken');

	decoratedRequest.method = definition.verb;
	decoratedRequest.url = generateURL(definition);

	oauthParams['oauth_signature'] = request.sdk.transport.createSignature(decoratedRequest, oauthParams);
	oauthParams['oauth_callback'] = oauthCallback;

	return request.sdk.transport.call(
		request.sdk.findDefinition(apiV1, 'getRequestToken'),
		oauthParams
	).then(function (response) {
		// clean up the response for consumers
		var returnObj = response.body;

		returnObj.authorizationURL = definition.schema.schemes[0] + '://' + definition.schema.host + definition.schema.basePath + '/oauth/authorize?oauth_token=' + response.body.oauth_token;
		return returnObj;
	});
}

function getAccessToken (request, oauthToken, oauthTokenSecret, oauthVerifier) {
	var oauthParams = {
			oauth_nonce: request.sdk.transport.createNonce(),
			oauth_timestamp: '' + Math.round(Date.now() / 1000),
			oauth_signature_method: 'HMAC-SHA1',
			oauth_version: '1.0',
			oauth_consumer_key: request.sdk.transport.config.apiKey,
			oauth_token: oauthToken,
			oauth_verifier: oauthVerifier
		},
		decoratedRequest = request,
		definition = request.sdk.findDefinition(apiV1, 'getAccessToken');

	decoratedRequest.method = definition.verb;
	decoratedRequest.url = generateURL(definition);

	oauthParams['oauth_signature'] = request.sdk.transport.createSignature(decoratedRequest, oauthParams, oauthTokenSecret);

	return request.sdk.transport.call(
		request.sdk.findDefinition(apiV1, 'getAccessToken'),
		oauthParams,
		{} // no additional params
	)
	.then(function (response) {
		// clean up the response for consumers
		return response.body;
	});
}

module.exports = function () {

	var request = this;

	/* istanbul ignore next */
	if (process.browser) {
		throw new Error('Authentication is not supported in the browser at this time.');
	}

	return {

		prepareRequestToken: function (oauthCallbackURI) {
			/* istanbul ignore next */
			if (process.browser) {
				console.warn('It is stringly discouraged to make this call from a browser. See github.com/flickr/flickr for more details.');
			}

			return getRequestToken(request, oauthCallbackURI);
		},

		/**
		 * We handle the auth pop up ourself, or defer to the user
		 * The callback page in the popup will beacon back the oauth token
		 * We then use that to request an access token
		 * And when that comes back we're authed!
		 */
		authenticateUser: function (requestToken, requestTokenSecret, requestTokenVerifier) {

			return new Promise(function (resolve, reject) {

				var requestTokenDefinition = request.sdk.findDefinition(apiV1, 'getRequestToken');
				var requestURL = requestTokenDefinition.schema.schemes[0] + '://' + requestTokenDefinition.schema.host + requestTokenDefinition.schema.basePath + '/oauth/authorize?oauth_token=' + requestToken;

				/* istanbul ignore else  */
				if (!process.browser) {
					if (!requestTokenVerifier) {
						reject(new Error('You must specify the request token verifier.'));
					}

					resolve({
						'oauth_verifier': requestTokenVerifier
					});
				} else {

					var popup = window.open(requestURL);
					window['flickr-sdk-auth-success'] = function (data) {
						resolve(data);
					};
					window['flickr-sdk-auth-failure'] = function (data) {
						reject(data);
					};
				}
			})
			.then(function (data) {
				return getAccessToken(request, requestToken, requestTokenSecret, data.oauth_verifier);
			});
		}
	};
};
}).call(this,require('_process'))
},{"../generate-url.js":3,"_process":15,"flickr-api-swagger":20}],8:[function(require,module,exports){
/**
 * Group of methods for working with galleries
 * @memberof! FlickrRequest#
 * @function galleries
 * @param {string=} galleryID - ID of the gallery we're working with
 * @returns {object} verbs for working with galleries and child namespaces
 */

var apiV1 = require('flickr-api-swagger');

module.exports = function (galleryID) {

	var request = this;

	return {

		/**
		 * Group of methods for working with media in galleries
		 * @memberof! FlickrRequest#
		 * @function galleries.media
		 * @returns {object} verbs for working with a gallery and child namespaces
		 */
		media: function () {

			return {

				/**
				 * Gets photos from a gallery
				 * @memberof! FlickrRequest#
				 * @function galleries.media.get
				 * @param {object} additionalParams - extra data to attach to the API call
				 * @returns {object} an array of photos in a gallery
				 */
				get: function (additionalParams) {
					return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getGalleryPhotosByID'), { "gallery_id": galleryID }, request.auth, additionalParams);
				}

			};

		}

	};

};
},{"flickr-api-swagger":20}],9:[function(require,module,exports){
/**
 * Group of methods for working with groups
 * @memberof! FlickrRequest#
 * @function groups
 * @param {string=} groupID - ID of the group we're working with
 * @returns {object} verbs for working with a photo and child namespaces
 */

var apiV1 = require('flickr-api-swagger');

module.exports = function (groupID) {

	var request = this;

	return {

		/**
		 * Gets an individual group
		 * @memberof! FlickrRequest#
		 * @function groups.get
		 * @param {object} additionalParams - extra data to attach to the API call
		 * @returns {object} an existing group object
		 */
		get: function (additionalParams) {
			return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getGroupByID'), { "group_id": groupID }, request.auth, additionalParams);
		},

		/**
		 * Group of methods for working with media in groups
		 * @memberof! FlickrRequest#
		 * @function groups.media
		 * @returns {object} verbs for working with a group's media and child namespaces
		 */
		media: function () {

			return {

				/**
				 * Gets photos in a group
				 * @memberof! FlickrRequest#
				 * @function groups.media.get
				 * @param {object} additionalParams - extra data to attach to the API call
				 * @returns {object} a bunch of photos in a group
				 */
				get: function (additionalParams) {
					return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getGroupPhotosByID'), { "group_id": groupID }, request.auth, additionalParams);
				}

			};

		},

		/**
		 * Group of methods for working with group discussions
		 * @memberof! FlickrRequest#
		 * @function groups.discussions
		 * @returns {object} verbs for working with a group's discussions and child namespaces
		 */
		discussions: function () {

			return {

				/**
				 * Gets discussions in a group
				 * @memberof! FlickrRequest#
				 * @function groups.discussions.get
				 * @param {object} additionalParams - extra data to attach to the API call
				 * @returns {object} a list of discussion topics in a group
				 */
				get: function (additionalParams) {
					return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getGroupDiscussionsByID'), { "group_id": groupID }, request.auth, additionalParams);
				}

			};

		}

	};

};
},{"flickr-api-swagger":20}],10:[function(require,module,exports){
// Copyright 2016 Yahoo Inc.
// Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.

/**
 * Group of methods for working with media
 * @function media
 * @memberof! FlickrRequest#
 * @param {string=} mediaID - ID of the media we're working with
 * @returns {object} verbs for working with a piece of media and child namespaces
 */

var apiV1 = require('flickr-api-swagger');
var nsidRegex = new RegExp("^[0-9]+@N[0-9]+$");

module.exports = function (mediaID) {

	var request = this;

	return {

		/**
		 * Gets an individual media item
		 * @memberof! FlickrRequest#
		 * @function media.get
		 * @param {object} additionalParams - extra data to attach to the API call
		 * @returns {object} an existing media object
		 */
		get: function (additionalParams) {
			return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getPhotoByID'), { "photo_id": mediaID }, request.auth, additionalParams);
		},

		/**
		 * Uploads an individual media item
		 * @memberof! FlickrRequest#
		 * @function media.post
		 * @param {object} additionalParams - extra data to attach to the API call
		 * @returns {object} a new photo object
		 */
		post: function (additionalParams) {
			return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'uploadPhoto'), {}, request.auth, additionalParams);
		},

        /**
         * Gets available sizes for the media item
		 * @memberOf! FlickrRequest#
		 * @function media.sizes
         * @returns {object} available sizes of the photo
         */
        sizes: function () {
            return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getPhotoSizesByID'), { "photo_id": mediaID }, request.auth);
        },

		/**
		 * Group of methods for performing searches
		 * @memberof! FlickrRequest#
		 * @function media.search
		 * @param {string} query - Search query.
		 * @returns {object} verbs for performing a search
		 */
		search: function (searchQuery) {

			return {

				/**
				 * Gets a list of media matching the search query
				 * @memberof! FlickrRequest#
				 * @function media.search.get
				 * @param {object} additionalParams - extra data to attach to the API call
				 * @param {number} additionalParams.pageNumber - Which page of results
				 * @param {number} additionalParams.pageSize - How many results to fetch per page
				 * @returns {object} a list of media objects and details about the result
				 */
				get: function (additionalParams) {
					return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getMediaBySearch'), { "text": searchQuery }, request.auth, additionalParams);
				}

			};

		},

		/**
		 * Group of methods for fetching the context around an item of media
		 * @memberof! FlickrRequest#
		 * @function media.context
		 * @param {number} contextSize - How many photos each side of this should we fetch
		 * @returns {object} verbs for working with context and child namespaces
		 */
		context: function (contextSize) {

			return {

				/**
				 * Group of methods for getting photolist context
				 * @memberof! FlickrRequest#
				 * @function media.context.photolist
				 * @param {string} photolistID - ID for the photo list where getting context for
				 * @returns {object} verbs for performing a photolist context call
				 */
				photolist: function (photolistID) {

					return {

						/**
						 * Returns two lists of photos either side of this one
						 * @memberof! FlickrRequest#
						 * @function media.context.photolist.get
						 * @param {object} additionalParams - extra data to attach to the API call
						 * @returns {object} two arrays of photo objects
						 */
						get: function (additionalParams) {
							return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getPhotolistContextByID'), {
								"photo_id": mediaID,
								"photolist_id": photolistID,
								"num_next": contextSize,
								"num_prev": contextSize
							}, request.auth, additionalParams);
						}

					};

				},

				/**
				 * Group of methods for getting an album context
				 * @memberof! FlickrRequest#
				 * @function media.context.album
				 * @param {string} albumID - ID for the album we're getting context for
				 * @returns {object} verbs for performing an album context call
				 */
				album: function (albumID) {

					return {

						/**
						 * Returns two lists of photos either side of this one in the album context
						 * @memberof! FlickrRequest#
						 * @function media.context.album.get
						 * @param {object} additionalParams - extra data to attach to the API call
						 * @returns {object} two arrays of photo objects
						 */
						get: function (additionalParams) {
							return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getAlbumContextByID'), {
								"photo_id": mediaID,
								"photoset_id": albumID,
								"num_next": contextSize,
								"num_prev": contextSize
							}, request.auth, additionalParams);
						}

					};

				},

				/**
				 * Group of methods for getting a sharedEntity context
				 * @memberof! FlickrRequest#
				 * @function media.context.sharedEntity
				 * @param {string} shareID - ID of the shared entity
				 * @param {string} shareOwner - ID of the owner of this shared entity
				 * @returns {object} verbs for performing a sharedEntity context call
				 */
				sharedEntity: function (shareID, shareOwner) {

					return {

						/**
						 * Returns two lists of photos either side of this one in the sharedEntity context
						 * @memberof! FlickrRequest#
						 * @function media.context.sharedEntity.get
						 * @param {object} additionalParams - extra data to attach to the API call
						 * @returns {object} two arrays of photo objects
						 */
						get: function (additionalParams) {
							return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getAlbumContextByID'), {
								"photo_id": mediaID,
								"share_code": shareID,
								"share_owner": shareOwner,
								"gp_code": shareID,
								"gp_owner": shareOwner,
								"num_next": contextSize,
								"num_prev": contextSize
							}, request.auth, additionalParams);
						}

					};

				},

				/**
				 * Group of methods for getting a photostream context
				 * @memberof! FlickrRequest#
				 * @function media.context.photostream
				 * @returns {object} verbs for performing a photostream context call
				 */
				photostream: function () {

					return {

						/**
						 * Returns two lists of photos either side of this one in the photostream context
						 * @memberof! FlickrRequest#
						 * @function media.context.photostream.get
						 * @param {object} additionalParams - extra data to attach to the API call
						 * @param {number} additionalParams.order_by - Two options: []'datetaken', 'dateposted'], defaults to 'dateposted'
						 * @param {number} additionalParams.view_as - Four options: ['public', 'friend', 'family', 'ff'], defaults to calling user's relationship
						 * @returns {object} two arrays of photo objects
						 */
						get: function (additionalParams) {
							return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getPhotostreamContextByID'), {
								"photo_id": mediaID,
								"num_next": contextSize,
								"num_prev": contextSize
							}, request.auth, additionalParams);
						}

					};

				},

				/**
				 * Group of methods for getting a favorites context
				 * @memberof! FlickrRequest#
				 * @function media.context.favorites
				 * @param {string} personID - ID or path_alias for person who's favorites define this context
				 * @returns {object} verbs for performing a favorites context call
				 */
				favorites: function (personID) {

					return {

						/**
						 * Returns two lists of photos either side of this one in the favorites context
						 * @memberof! FlickrRequest#
						 * @function media.context.favorites.get
						 * @param {object} additionalParams - extra data to attach to the API call
						 * @returns {object} two arrays of photo objects
						 */
						get: function (additionalParams) {
							return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getFavoritesContextByID'), {
								"photo_id": mediaID,
								"user_id": (nsidRegex.test(personID)) ? personID : null,
								"path_alias": (nsidRegex.test(personID)) ? null : personID,
								"num_next": contextSize,
								"num_prev": contextSize
							}, request.auth, additionalParams);
						}

					};

				}

			};

		}

	};

};

},{"flickr-api-swagger":20}],11:[function(require,module,exports){
/**
 * Group of methods for working with users
 * @memberof! FlickrRequest#
 * @function people
 * @param {string=} personID - ID of the people
 * @returns {object} verbs for working with people and child namespaces
 */

var apiV1 = require('flickr-api-swagger');

module.exports = function (personID) {

	var request = this;

	return {

		/**
		 * Gets this person's information
		 * @memberof! FlickrRequest#
		 * @function people.people.get
		 * @param {object} additionalParams - extra data to attach to the API call
		 * @returns {object} information about the person
		 */
		get: function (additionalParams) {
			return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getPersonByID'), { "user_id": personID }, request.auth, additionalParams);
		},

		/**
		 * Group of methods for getting at a people's media
		 * @memberof! FlickrRequest#
		 * @function people.media
		 * @returns {object} verbs for working with people and child namespaces
		 */
		media: function () {

			return {

				/**
				 * Gets this people's public photostream
				 * @memberof! FlickrRequest#
				 * @function people.media.get
				 * @param {object} additionalParams - extra data to attach to the API call
				 * @returns {object} an array of public photos belonging to this people
				 */
				get: function (additionalParams) {
					return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getMediaByPersonID'), { "user_id": personID }, request.auth, additionalParams);
				}

			};

		},

		/**
		 * Group of methods for working with favorites
		 * @memberof! FlickrRequest#
		 * @function people.favorites
		 * @returns {object} verbs for working with favorites and child namespaces
		 */
		favorites: function () {

			return {

				/**
				 * Group of methods for working with media in favorites
				 * @memberof! FlickrRequest#
				 * @function people.favorites.media
				 * @returns {object} verbs for working with favorites and child namespaces
				 */
				media: function () {

					return {

						/**
						 * Gets this people's favorite photos
						 * @memberof! FlickrRequest#
						 * @function people.favorites.media.get
						 * @param {object} additionalParams - extra data to attach to the API call
						 * @returns {object} an array of photos in favorites
						 */
						get: function (additionalParams) {
							return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getFavoritesByPersonID'), { "user_id": personID }, request.auth, additionalParams);
						}

					};

				}

			};

		},

		/**
		 * Group of methods for working with a people's albums
		 * @memberof! FlickrRequest#
		 * @function people.albums
		 * @returns {object} verbs for working with a people's albums and child namespaces
		 */
		albums: function () {

			return {

				/**
				 * Gets this people's albums
				 * @memberof! FlickrRequest#
				 * @function people.albums.media.get
				 * @param {object} additionalParams - extra data to attach to the API call
				 * @returns {object} an array of albums belonging to this people
				 */
				get: function (additionalParams) {
					return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'getAlbumsByPersonID'), { "user_id": personID }, request.auth, additionalParams);
				}

			};

		}

	};

};
},{"flickr-api-swagger":20}],12:[function(require,module,exports){
// Copyright 2016 Yahoo Inc.
// Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.

/**
 * Group of methods for working with the validation (`test`) endpoints of the Flickr API
 * @function validate
 * @memberof! FlickrRequest#
 * @returns {object} verbs for working with validation
 */

var apiV1 = require('flickr-api-swagger');

module.exports = function () {
	var request = this;

	return {

		/**
		 * Echo a parameter back from the API
		 * @memberof! FlickrRequest#
		 * @function validate.echo
		 * @returns {object} an echo'd response of the input
		 */
		echo: function () {
			return request.sdk.transport.call(request.sdk.findDefinition(apiV1, 'echo'), { 'echo': 'hello world' }, request.auth, {});
		}
	};
};

},{"flickr-api-swagger":20}],13:[function(require,module,exports){
// Copyright 2016 Yahoo Inc.
// Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.

var except = require('except');

/**
 * VALIDATE
 * @param {Object} params the params we're passing to the API
 * @param {Object} paramConfig Swagger API param definitions for us to match against
 * @returns {Object} nothing if no errors, details of error they exist
 */
module.exports = function (params, paramConfig) {

	var cleanParams = except(params, ['api_key']);
	var paramConfigObject = {};
	var errors = [];

	// Map array to keys for easy parsing
	paramConfig.forEach(function (param) {
		paramConfigObject[param.name] = param;
	});

	// Create a list of the required params
	var requiredParams = Object.keys(paramConfigObject).filter(function (key) {
		return paramConfigObject[key].required && key !== 'api_key';
	});

	// Loop through required params and make sure they exist
	requiredParams.forEach(function (requiredParam) {
		if (typeof cleanParams[requiredParam] === "undefined") {
			errors.push("Required param - " + requiredParam + " - not specified");
		}
	});

	// Loop through all the params in the config for this path
	Object.keys(paramConfigObject).forEach(function (paramKey) {

		// First check if it's even been passed in
		if (cleanParams[paramKey]) {

			// Check type
			/* istanbul ignore else */
			if (paramConfigObject[paramKey].type) {
				var paramValue = cleanParams[paramKey];

				// Identify the type
				var actualType = (typeof paramValue === "number") ? (Math.floor(paramValue) === paramValue ? "integer" : "number")  : typeof paramValue;

				// Handle the File type
				/* istanbul ignore next */
				actualType = (typeof File !== "undefined" && paramValue instanceof File) ? "file" : actualType;

				var expectedType = paramConfigObject[paramKey].type;

				// You can't specify multiple types in Swagger but for
				// file uploads done on the server you can pass in a
				// string path to the media rather than a File object
				actualType = (expectedType === "file" && actualType === "string") ? "file" : actualType;

				// Handle the case where integers are considered numbers too
				actualType = (expectedType === "number" && actualType === "integer" ? "number" : actualType);

				if (actualType !== expectedType) {
					errors.push("Param " + paramKey + " with type " + actualType + " not of the expected type: " + expectedType);
				}
			}

			// Check possible values
			if (paramConfigObject[paramKey].enum && paramConfigObject[paramKey].enum.indexOf(cleanParams[paramKey]) < 0) {
				errors.push("Param " + paramKey + " with value " + cleanParams[paramKey] + " not one of possible options: [" + paramConfigObject[paramKey].enum.join(", ") + "]");
			}

			// Check it matches the pattern if one is specified
			if (paramConfigObject[paramKey].type === "string" && paramConfigObject[paramKey].pattern) {
				if (typeof cleanParams[paramKey] === "string" && !cleanParams[paramKey].match(new RegExp(paramConfigObject[paramKey].pattern))) {
					errors.push("Param " + paramKey + " with value " + cleanParams[paramKey] + " doesn't match pattern " + paramConfigObject[paramKey].pattern);
				}
			}

		}

	});

	return errors;

};

},{"except":17}],14:[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

},{}],15:[function(require,module,exports){

},{}],16:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else {
        root.deepmerge = factory();
    }
}(this, function () {

return function deepmerge(target, src) {
    var array = Array.isArray(src);
    var dst = array && [] || {};

    if (array) {
        target = target || [];
        dst = dst.concat(target);
        src.forEach(function(e, i) {
            if (typeof dst[i] === 'undefined') {
                dst[i] = e;
            } else if (typeof e === 'object') {
                dst[i] = deepmerge(target[i], e);
            } else {
                if (target.indexOf(e) === -1) {
                    dst.push(e);
                }
            }
        });
    } else {
        if (target && typeof target === 'object') {
            Object.keys(target).forEach(function (key) {
                dst[key] = target[key];
            })
        }
        Object.keys(src).forEach(function (key) {
            if (typeof src[key] !== 'object' || !src[key]) {
                dst[key] = src[key];
            }
            else {
                if (!target[key]) {
                    dst[key] = src[key];
                } else {
                    dst[key] = deepmerge(target[key], src[key]);
                }
            }
        });
    }

    return dst;
}

}));

},{}],17:[function(require,module,exports){
'use strict';

var ap      = Array.prototype;
var concat  = ap.concat;
var slice   = ap.slice;
var indexOf = require('indexof');

function except(object) {
  var result = {};
  var keys = concat.apply(ap, slice.call(arguments, 1));

  for (var key in object) {
    if (indexOf(keys, key) === -1) {
      result[key] = object[key];
    }
  }

  return result;
}

module.exports = except;

},{"indexof":18}],18:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],19:[function(require,module,exports){
module.exports={
  "swagger": "2.0",
  "info": {
    "title": "Flickr API Schema",
    "description": "A subset of Flickr's API defined in Swagger format.",
    "termsOfService": "https://www.flickr.com/services/api/tos/",
    "version": "1.0.0"
  },
  "basePath": "/services",
  "host": "api.flickr.com",
  "schemes": [
    "https"
  ],
  "consumes": [
    "multipart/form-data"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/rest?method=flickr.favorites.getList": {
      "get": {
        "operationId": "getFavoritesByPersonID",
        "description": "Returns a list of the user's favorite photos. Only photos which the calling user has permission to see are returned.",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "user_id",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "min_fave_date",
            "in": "query",
            "type": "number"
          },
          {
            "name": "max_fave_date",
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "in": "query",
            "type": "number"
          },
          {
            "name": "per_page",
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "page": {
                  "type": "number"
                },
                "pages": {
                  "type": "number"
                },
                "perpage": {
                  "type": "number"
                },
                "total": {
                  "type": "number"
                },
                "photos": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Photo"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.people.getPhotos": {
      "get": {
        "operationId": "getMediaByPersonID",
        "description": "Return photos from the given user's photostream",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "user_id",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "safe_search",
            "in": "query",
            "type": "number"
          },
          {
            "name": "min_upload_date",
            "in": "query",
            "type": "number"
          },
          {
            "name": "max_upload_date",
            "in": "query",
            "type": "number"
          },
          {
            "name": "min_taken_date",
            "in": "query",
            "type": "number"
          },
          {
            "name": "max_taken_date",
            "in": "query",
            "type": "number"
          },
          {
            "name": "content_type",
            "in": "query",
            "type": "number"
          },
          {
            "name": "privacy_filter",
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "in": "query",
            "type": "number"
          },
          {
            "name": "per_page",
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "page": {
                  "type": "number"
                },
                "pages": {
                  "type": "number"
                },
                "perpage": {
                  "type": "number"
                },
                "total": {
                  "type": "number"
                },
                "photos": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Photo"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.photosets.getList": {
      "get": {
        "operationId": "getAlbumsByPersonID",
        "description": "Returns the albums belonging to the specified user",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "user_id",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "page",
            "in": "query",
            "type": "number"
          },
          {
            "name": "per_page",
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "page": {
                  "type": "number"
                },
                "pages": {
                  "type": "number"
                },
                "perpage": {
                  "type": "number"
                },
                "total": {
                  "type": "number"
                },
                "photosets": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Album"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.favorites.getContext": {
      "get": {
        "operationId": "getFavoritesContextByID",
        "description": "Returns next and previous favorites for a photo in a user's favorites",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "photo_id",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^[0-9]+$"
          },
          {
            "name": "user_id",
            "in": "query",
            "required": false,
            "type": "string",
            "pattern": "^([0-9]+@N[0-9]+)|([0-9a-zA-Z-_]+)$"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "object",
                  "properties": {
                    "_content": {
                      "type": "string"
                    }
                  }
                },
                "prevphoto": {
                  "$ref": "#/definitions/ContextPhoto"
                },
                "nextphoto": {
                  "$ref": "#/definitions/ContextPhoto"
                },
                "stat": {
                  "$ref": "#/definitions/Stat"
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.groups.getInfo": {
      "get": {
        "operationId": "getGroupByID",
        "description": "Get information about a group",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "group_id",
            "in": "query",
            "required": false,
            "type": "string",
            "pattern": "^([0-9]+@N[0-9]+)|([0-9a-zA-Z-_]+)$"
          },
          {
            "name": "group_path_alias",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "lang",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "group": {
                  "$ref": "#/definitions/Group"
                },
                "stat": {
                  "$ref": "#/definitions/Stat"
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.groups.pools.getPhotos": {
      "get": {
        "operationId": "getGroupPhotosByID",
        "description": "Returns a list of pool photos for a given group",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "group_id",
            "in": "query",
            "required": false,
            "type": "string",
            "pattern": "^([0-9]+@N[0-9]+)|([0-9a-zA-Z-_]+)$"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "photos": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Photo"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.groups.discuss.topics.getList": {
      "get": {
        "operationId": "getGroupDiscussionsByID",
        "description": "Get a list of discussion topics in a group.",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "group_id",
            "in": "query",
            "required": false,
            "type": "string",
            "pattern": "^([0-9]+@N[0-9]+)|([0-9a-zA-Z-_]+)$"
          },
          {
            "name": "page",
            "in": "query",
            "type": "number"
          },
          {
            "name": "per_page",
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "iconserver": {
                  "type": "number"
                },
                "iconfarm": {
                  "type": "number"
                },
                "name": {
                  "type": "string"
                },
                "members": {
                  "type": "number"
                },
                "privacy": {
                  "type": "number"
                },
                "lang": {
                  "type": "string"
                },
                "ispoolmoderated": {
                  "type": "boolean"
                },
                "total": {
                  "type": "number"
                },
                "page": {
                  "type": "number"
                },
                "per_page": {
                  "type": "number"
                },
                "pages": {
                  "type": "number"
                },
                "topics": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Topic"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.groups.discuss.replies.getInfo": {
      "get": {
        "operationId": "getGroupTopicRepliesByID",
        "description": "Get information on a group topic reply",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "group_id",
            "in": "query",
            "required": false,
            "type": "string",
            "pattern": "^([0-9]+@N[0-9]+)|([0-9a-zA-Z-_]+)$"
          },
          {
            "name": "topic_id",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^[0-9]+$"
          },
          {
            "name": "reply_id",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^[0-9]+$"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "reply": {
                  "$ref": "#/definitions/TopicReply"
                },
                "stat": {
                  "$ref": "#/definitions/Stat"
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.groups.discuss.topics.getInfo": {
      "get": {
        "operationId": "getGroupTopicByID",
        "description": "Get information about a group discussion topic",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "group_id",
            "in": "query",
            "required": false,
            "type": "string",
            "pattern": "^([0-9]+@N[0-9]+)|([0-9a-zA-Z-_]+)$"
          },
          {
            "name": "topic_id",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^[0-9]+$"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "topic": {
                  "$ref": "#/definitions/Topic"
                },
                "stat": {
                  "$ref": "#/definitions/Stat"
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.groups.pools.getContext": {
      "get": {
        "operationId": "getGroupPhotosByID",
        "description": "Returns next and previous photos for a photo in a group pool",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "photo_id",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^[0-9]+$"
          },
          {
            "name": "group_id",
            "in": "query",
            "required": false,
            "type": "string",
            "pattern": "^([0-9]+@N[0-9]+)|([0-9a-zA-Z-_]+)$"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "object",
                  "properties": {
                    "_content": {
                      "type": "string"
                    }
                  }
                },
                "prevphoto": {
                  "$ref": "#/definitions/ContextPhoto"
                },
                "nextphoto": {
                  "$ref": "#/definitions/ContextPhoto"
                },
                "stat": {
                  "$ref": "#/definitions/Stat"
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.photolist.getContext": {
      "get": {
        "operationId": "getPhotolistContextByID",
        "description": "Returns next and previous photos in a photo list",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "photo_id",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^[0-9]+$"
          },
          {
            "name": "photolist_id",
            "in": "query",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "object",
                  "properties": {
                    "_content": {
                      "type": "string"
                    }
                  }
                },
                "prevphoto": {
                  "$ref": "#/definitions/ContextPhoto"
                },
                "nextphoto": {
                  "$ref": "#/definitions/ContextPhoto"
                },
                "stat": {
                  "$ref": "#/definitions/Stat"
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.photos.getContext": {
      "get": {
        "operationId": "getPhotostreamContextByID",
        "description": "Returns next and previous photos for a photo in a photostream",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "photo_id",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^[0-9]+$"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "object",
                  "properties": {
                    "_content": {
                      "type": "string"
                    }
                  }
                },
                "prevphoto": {
                  "$ref": "#/definitions/ContextPhoto"
                },
                "nextphoto": {
                  "$ref": "#/definitions/ContextPhoto"
                },
                "stat": {
                  "$ref": "#/definitions/Stat"
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.photos.licenses.getInfo": {
      "get": {
        "operationId": "getLicenseByID",
        "description": "Fetches a list of available photo licenses for Flickr",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "licenses": {
                  "type": "object",
                  "properties": {
                    "license": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "id": {
                            "type": "integer"
                          },
                          "name": {
                            "type": "string"
                          },
                          "url": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "stat": {
                  "$ref": "#/definitions/Stat"
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.people.getInfo": {
      "get": {
        "operationId": "getPersonByID",
        "description": "Returns a person",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "user_id",
            "in": "query",
            "required": false,
            "type": "string",
            "pattern": "^([0-9]+@N[0-9]+)|([0-9a-zA-Z-_]+)$"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "person": {
                  "$ref": "#/definitions/Person"
                },
                "stat": {
                  "$ref": "#/definitions/Stat"
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.photos.getExif": {
      "get": {
        "operationId": "getPhotoExifByID",
        "description": "Retrieves a list of EXIF/TIFF/GPS tags for a given photo. The calling user must have permission to view the photo.",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "photo_id",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^[0-9]+$"
          },
          {
            "name": "secret",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "photo": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string"
                    },
                    "secret": {
                      "type": "string"
                    },
                    "server": {
                      "type": "string"
                    },
                    "farm": {
                      "type": "string"
                    },
                    "camera": {
                      "type": "string"
                    },
                    "exif": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "tagspace": {
                            "type": "string"
                          },
                          "tagspaceid": {
                            "type": "string"
                          },
                          "tag": {
                            "type": "string"
                          },
                          "label": {
                            "type": "string"
                          },
                          "raw": {
                            "type": "object",
                            "properties": {
                              "_content": {
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "stat": {
                  "$ref": "#/definitions/Stat"
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.photos.getInfo": {
      "get": {
        "operationId": "getPhotoByID",
        "description": "Returns a photo",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "photo_id",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^[0-9]+$"
          }
        ],
        "responses": {
          "200": {
            "description": "a photo",
            "schema": {
              "type": "object",
              "properties": {
                "photo": {
                  "$ref": "#/definitions/Photo"
                },
                "stat": {
                  "$ref": "#/definitions/Stat"
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.photos.getSizes": {
      "get": {
        "operationId": "getPhotoSizesByID",
        "description": "Returns photo sizes",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "photo_id",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^[0-9]+$"
          }
        ],
        "responses": {
          "200": {
            "description": "Photo sizes",
            "schema": {
              "type": "object",
              "properties": {
                "sizes": {
                  "type": "object",
                  "properties": {
                    "canblog": {
                      "type": "number"
                    },
                    "canprint": {
                      "type": "number"
                    },
                    "candownload": {
                      "type": "number"
                    },
                    "sizes": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Size"
                      }
                    }
                  }
                },
                "stat": {
                  "$ref": "#/definitions/Stat"
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.photosets.getContext": {
      "get": {
        "operationId": "getAlbumContextByID",
        "description": "Returns next and previous photos for a photo in a set",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "photo_id",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^[0-9]+$"
          },
          {
            "name": "photoset_id",
            "in": "query",
            "required": false,
            "type": "string",
            "pattern": "^[0-9]+$"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "object",
                  "properties": {
                    "_content": {
                      "type": "string"
                    }
                  }
                },
                "prevphoto": {
                  "$ref": "#/definitions/ContextPhoto"
                },
                "nextphoto": {
                  "$ref": "#/definitions/ContextPhoto"
                },
                "stat": {
                  "$ref": "#/definitions/Stat"
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.photosets.getPhotos": {
      "get": {
        "operationId": "getAlbumByID",
        "description": "Returns a list of photos in an album.",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "photoset_id",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^[0-9]+$"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "photoset": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Photo"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.galleries.getPhotos": {
      "get": {
        "operationId": "getGalleryPhotosByID",
        "description": "Returns a list of photos in a gallery.",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "gallery_id",
            "in": "query",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "photos": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Photo"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest?method=flickr.photos.search": {
      "get": {
        "operationId": "getMediaBySearch",
        "description": "Return a list of photos matching some criteria.",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "text",
            "description": "A free text search. Photos who's title, description or tags contain the text will be returned. You can exclude results that match a term by prepending it with a - character.",
            "in": "query",
            "type": "string"
          },
          {
            "name": "tags",
            "description": "A comma-delimited list of tags. Photos with one or more of the tags listed will be returned. You can exclude results that match a term by prepending it with a - character.",
            "in": "query",
            "type": "string"
          },
          {
            "name": "user_id",
            "description": "The NSID of the user who's photo to search. If this parameter isn't passed then everybody's public photos will be searched. A value of \"me\" will search against the calling user's photos for authenticated calls.",
            "in": "query",
            "type": "string"
          },
          {
            "name": "min_upload_date",
            "description": "Minimum upload date. Photos with an upload date greater than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime.",
            "in": "query",
            "type": "string"
          },
          {
            "name": "max_upload_date",
            "description": "Maximum upload date. Photos with an upload date less than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime.",
            "in": "query",
            "type": "string"
          },
          {
            "name": "min_taken_date",
            "description": "Minimum taken date. Photos with an taken date greater than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp.",
            "in": "query",
            "type": "string"
          },
          {
            "name": "max_taken_date",
            "description": "Maximum taken date. Photos with an taken date less than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp.",
            "in": "query",
            "type": "string"
          },
          {
            "name": "license",
            "description": "The license id for photos (for possible values see the flickr.photos.licenses.getInfo method). Multiple licenses may be comma-separated.",
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort",
            "description": "The order in which to sort returned photos. Deafults to date-posted-desc (unless you are doing a radial geo query, in which case the default sorting is by ascending distance from the point specified). The possible values are:\n  date-posted-asc,\n  date-posted-desc,\n  date-taken-asc,\n  date-taken-desc,\n  interestingness-desc,\n  interestingness-asc, and\n  relevance.\n",
            "in": "query",
            "type": "string"
          },
          {
            "name": "privacy_filter",
            "description": "Return photos only matching a certain privacy level. This only applies when making an authenticated call to view photos you own. Valid values are:,\n  1: public photos,\n  2: private photos visible to friends,\n  3: private photos visible to family,\n  4: private photos visible to friends & family,\n  5: completely private photos\n",
            "in": "query",
            "type": "number"
          },
          {
            "name": "bbox",
            "description": "A comma-delimited list of 4 values defining the Bounding Box of the area that will be searched.",
            "in": "query",
            "type": "string"
          },
          {
            "name": "accuracy",
            "description": "Recorded accuracy level of the location information. Current range is 1-16:\n  World level is 1\n  Country is ~3\n  Region is ~6\n  City is ~11\n  Street is ~16\n",
            "in": "query",
            "type": "string"
          },
          {
            "name": "safe_search",
            "description": "Safe search setting:\n  1: for safe,\n  2: for moderate,\n  3: for restricted\n",
            "in": "query",
            "type": "number"
          },
          {
            "name": "content_type",
            "description": "Content Type setting:\n  1: photos only.\n  2: screenshots only.\n  3: 'other' only.\n  4: photos and screenshots.\n  5: screenshots and 'other'.\n  6: photos and 'other'.\n  7: photos, screenshots, and 'other' (all).\n",
            "in": "query",
            "type": "number"
          },
          {
            "name": "machine_tags",
            "description": "Aside from passing in a fully formed machine tag, there is a special syntax for searching on specific properties : Find photos using the 'dc' namespace : \"machine_tags\" => \"dc:\" Find photos with a title in the 'dc' namespace : \"machine_tags\" => \"dc:title=\" Find photos titled \"mr. camera\" in the 'dc' namespace : \"machine_tags\" => \"dc:title=\\\"mr. camera\\\" Find photos whose value is \"mr. camera\" : \"machine_tags\" => \"*:*=\\\"mr. camera\\\"\" Find photos that have a title, in any namespace : \"machine_tags\" => \"*:title=\" Find photos that have a title, in any namespace, whose value is \"mr. camera\" : \"machine_tags\" => \"*:title=\\\"mr. camera\\\"\" Find photos, in the 'dc' namespace whose value is \"mr. camera\" : \"machine_tags\" => \"dc:*=\\\"mr. camera\\\"\" Multiple machine tags may be queried by passing a comma-separated list. The number of machine tags you can pass in a single query depends on the tag mode (AND or OR) that you are querying with. \"AND\" queries are limited to (16) machine tags. \"OR\" queries are limited to (8).\n",
            "in": "query",
            "type": "string"
          },
          {
            "name": "machine_tag_mode",
            "description": "Either 'any' for an OR combination of tags, or 'all' for an AND combination. Defaults to 'any' if not specified.",
            "in": "query",
            "type": "string"
          },
          {
            "name": "group_id",
            "description": "The id of a group who's pool to search. If specified, only matching photos posted to the group's pool will be returned.",
            "in": "query",
            "type": "string"
          },
          {
            "name": "contacts",
            "description": "Search your contacts. Either 'all' or 'ff' for just friends and family. (Experimental)",
            "in": "query",
            "type": "string"
          },
          {
            "name": "woe_id",
            "description": "A 32-bit identifier that uniquely represents spatial entities. (not used if bbox argument is present).",
            "in": "query",
            "type": "string"
          },
          {
            "name": "place_id",
            "description": "A Flickr place id. (not used if bbox argument is present). Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \"parameterless searches\" for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters ‚Äî If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).\n",
            "in": "query",
            "type": "string"
          },
          {
            "name": "media",
            "description": "Filter results by media type. Possible values are all (default), photos or videos",
            "in": "query",
            "type": "string"
          },
          {
            "name": "has_geo",
            "description": "Any photo that has been geotagged, or if the value is \"0\" any photo that has not been geotagged. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \"parameterless searches\" for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters ‚Äî If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).\n",
            "in": "query",
            "type": "string"
          },
          {
            "name": "geo_context",
            "description": "Geo context is a numeric value representing the photo's geotagginess beyond latitude and longitude. For example, you may wish to search for photos that were taken \"indoors\" or \"outdoors\". The current list of context IDs is: 0, not defined. 1, indoors. 2, outdoors. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \"parameterless searches\" for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters ‚Äî If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).\n",
            "in": "query",
            "type": "string"
          },
          {
            "name": "lat",
            "description": "A valid latitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \"parameterless searches\" for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters ‚Äî If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).\n",
            "in": "query",
            "type": "string"
          },
          {
            "name": "lon",
            "description": "A valid longitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \"parameterless searches\" for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters ‚Äî If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).\n",
            "in": "query",
            "type": "string"
          },
          {
            "name": "radius",
            "description": "A valid radius used for geo queries, greater than zero and less than 20 miles (or 32 kilometers), for use with point-based geo queries. The default value is 5 (km).",
            "in": "query",
            "type": "number"
          },
          {
            "name": "radius_units",
            "description": "The unit of measure when doing radial geo queries. Valid options are \"mi\" (miles) and \"km\" (kilometers). The default is \"km\".",
            "in": "query",
            "type": "string"
          },
          {
            "name": "is_commons",
            "description": "Limit the scope of the search to only photos that are part of the Flickr Commons project. Default is false.",
            "in": "query",
            "type": "boolean"
          },
          {
            "name": "in_gallery",
            "description": "Limit the scope of the search to only photos that are in a gallery? Default is false, search all photos.",
            "in": "query",
            "type": "boolean"
          },
          {
            "name": "is_getty",
            "description": "Limit the scope of the search to only photos that are for sale on Getty. Default is false.",
            "in": "query",
            "type": "boolean"
          },
          {
            "name": "per_page",
            "description": "Number of photos to return per page. If this argument is omitted, it defaults to 100. The maximum allowed value is 500.",
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "The page of results to return. If this argument is omitted, it defaults to 1.",
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "page": {
                  "type": "number"
                },
                "pages": {
                  "type": "number"
                },
                "perpage": {
                  "type": "number"
                },
                "total": {
                  "type": "number"
                },
                "photos": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Photo"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/upload": {
      "post": {
        "operationId": "uploadPhoto",
        "description": "Uploads a new photo to Flickr",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "formData",
            "required": true,
            "type": "string"
          },
          {
            "name": "photo",
            "in": "formData",
            "required": true,
            "type": "file"
          },
          {
            "name": "title",
            "in": "formData",
            "required": false,
            "type": "string"
          },
          {
            "name": "description",
            "in": "formData",
            "required": false,
            "type": "string"
          },
          {
            "name": "tags",
            "in": "formData",
            "required": false,
            "type": "string"
          },
          {
            "name": "is_public",
            "in": "formData",
            "required": false,
            "type": "string",
            "enum": [
              "0",
              "1"
            ]
          },
          {
            "name": "is_friend",
            "in": "formData",
            "required": false,
            "type": "string",
            "enum": [
              "0",
              "1"
            ]
          },
          {
            "name": "is_family",
            "in": "formData",
            "required": false,
            "type": "string",
            "enum": [
              "0",
              "1"
            ]
          },
          {
            "name": "safety_level",
            "in": "formData",
            "required": false,
            "type": "string",
            "enum": [
              "1",
              "2",
              "3"
            ]
          },
          {
            "name": "content_type",
            "in": "formData",
            "required": false,
            "type": "string",
            "enum": [
              "1",
              "2",
              "3"
            ]
          },
          {
            "name": "hidden",
            "in": "formData",
            "required": false,
            "type": "string",
            "enum": [
              "1",
              "2"
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object"
            }
          }
        }
      }
    },
    "/rest?method=flickr.test.echo": {
      "get": {
        "operationId": "echo",
        "description": "Echos the input parameters back in the response",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "api_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "echo",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "object",
              "properties": {
                "echo": {
                  "type": "object",
                  "properties": {
                    "_content": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/oauth/request_token": {
      "get": {
        "operationId": "getRequestToken",
        "description": "Returns an oauth token and oauth token secret",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "oauth_consumer_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "oauth_nonce",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "oauth_timestamp",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^[0-9]+$"
          },
          {
            "name": "oauth_signature_method",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "oauth_version",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "oauth_signature",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "oauth_callback",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^http.*$"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "string"
            }
          }
        }
      }
    },
    "/oauth/access_token": {
      "get": {
        "operationId": "getAccessToken",
        "description": "Returns an access token",
        "tags": [
          "Public"
        ],
        "parameters": [
          {
            "name": "oauth_consumer_key",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "oauth_nonce",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "oauth_timestamp",
            "in": "query",
            "required": true,
            "type": "string",
            "pattern": "^[0-9]+$"
          },
          {
            "name": "oauth_signature_method",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "oauth_version",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "oauth_signature",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "oauth_verifier",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "oauth_token",
            "in": "query",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "string"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "ContextPhoto": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "secret": {
          "type": "string"
        },
        "server": {
          "type": "string"
        },
        "farm": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "url": {
          "type": "string"
        },
        "thumb": {
          "type": "string"
        },
        "media": {
          "type": "string"
        },
        "owner": {
          "type": "string"
        },
        "license": {
          "type": "integer"
        },
        "safe": {
          "type": "boolean"
        },
        "is_faved": {
          "type": "boolean"
        }
      }
    },
    "ContextPhotos": {
      "type": "object",
      "properties": {
        "photos": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContextPhoto"
          }
        }
      }
    },
    "Cover": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "owner": {
          "type": "string"
        },
        "secret": {
          "type": "string"
        },
        "server": {
          "type": "string"
        },
        "farm": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "ispublic": {
          "type": "boolean"
        },
        "isfriend": {
          "type": "boolean"
        },
        "isfamily": {
          "type": "boolean"
        },
        "y": {
          "type": "string"
        }
      }
    },
    "Group": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "path_alias": {
          "type": "string"
        },
        "iconserver": {
          "type": "string"
        },
        "iconfarm": {
          "type": "string"
        },
        "name": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "description": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "rules": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "members": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "pool_count": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "topic_count": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "privacy": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "lang": {
          "type": "string"
        },
        "ispoolmoderated": {
          "type": "boolean"
        },
        "roles": {
          "type": "object",
          "properties": {
            "member": {
              "type": "string"
            },
            "moderator": {
              "type": "string"
            },
            "admin": {
              "type": "string"
            }
          }
        },
        "pool_rows": {
          "type": "integer"
        },
        "coverphoto_server": {
          "type": "string"
        },
        "coverphoto_farm": {
          "type": "string"
        },
        "coverphoto_url": {
          "$ref": "#/definitions/PhotoURLs"
        },
        "is_member": {
          "type": "boolean"
        },
        "is_moderator": {
          "type": "boolean"
        },
        "is_admin": {
          "type": "boolean"
        },
        "blast": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            },
            "date_blast_added": {
              "type": "string"
            },
            "user_id": {
              "type": "string"
            }
          }
        },
        "throttle": {
          "type": "object",
          "properties": {
            "count": {
              "type": "integer"
            },
            "mode": {
              "type": "string"
            },
            "remaining": {
              "type": "string"
            }
          }
        },
        "restrictions": {
          "type": "object",
          "properties": {
            "photos_ok": {
              "type": "boolean"
            },
            "videos_ok": {
              "type": "boolean"
            },
            "images_ok": {
              "type": "boolean"
            },
            "screens_ok": {
              "type": "boolean"
            },
            "art_ok": {
              "type": "boolean"
            },
            "safe_ok": {
              "type": "boolean"
            },
            "moderate_ok": {
              "type": "boolean"
            },
            "restricted_ok": {
              "type": "boolean"
            },
            "has_geo": {
              "type": "boolean"
            }
          }
        },
        "cover": {
          "$ref": "#/definitions/Cover"
        }
      }
    },
    "Note": {
      "type": "object",
      "properties": {
        "description": {
          "type": "string"
        }
      }
    },
    "Owner": {
      "type": "object",
      "properties": {
        "nsid": {
          "type": "string"
        },
        "username": {
          "type": "string"
        },
        "realname": {
          "type": "string"
        },
        "location": {
          "type": "string"
        },
        "iconserver": {
          "type": "string"
        },
        "iconfarm": {
          "type": "string"
        },
        "path_alias": {
          "type": "string"
        },
        "noindexfollow": {
          "type": "boolean"
        },
        "ispro": {
          "type": "boolean"
        },
        "is_ad_free": {
          "type": "boolean"
        }
      }
    },
    "Person": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "nsid": {
          "type": "string"
        },
        "ispro": {
          "type": "boolean"
        },
        "can_buy_pro": {
          "type": "boolean"
        },
        "iconserver": {
          "type": "string"
        },
        "iconfarm": {
          "type": "string"
        },
        "path_alias": {
          "type": "string"
        },
        "has_stats": {
          "type": "boolean"
        },
        "coverphoto_server": {
          "type": "string"
        },
        "coverphoto_farm": {
          "type": "string"
        },
        "is_ad_free": {
          "type": "boolean"
        },
        "coverphoto": {
          "$ref": "#/definitions/PhotoURLs"
        },
        "expire": {
          "type": "boolean"
        },
        "user_secret": {
          "type": "string"
        },
        "username": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "realname": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "mbox_sha1sum": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "location": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "timezone": {
          "type": "object",
          "properties": {
            "label": {
              "type": "string"
            },
            "offset": {
              "type": "string"
            },
            "timezone_id": {
              "type": "string"
            }
          }
        },
        "description": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "photosurl": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "profileurl": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "mobileurl": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "photos": {
          "type": "object",
          "properties": {
            "firstdatetaken": {
              "type": "object",
              "properties": {
                "_content": {
                  "type": "string"
                }
              }
            },
            "firstdate": {
              "type": "object",
              "properties": {
                "_content": {
                  "type": "string"
                }
              }
            },
            "count": {
              "type": "object",
              "properties": {
                "_content": {
                  "type": "string"
                }
              }
            },
            "views": {
              "type": "object",
              "properties": {
                "_content": {
                  "type": "string"
                }
              }
            }
          }
        },
        "yintl": {
          "type": "string"
        },
        "unread_messages": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "cover": {
          "$ref": "#/definitions/Cover"
        },
        "disable_keyboard_shortcuts": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        }
      }
    },
    "Photo": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "secret": {
          "type": "string"
        },
        "server": {
          "type": "string"
        },
        "farm": {
          "type": "string"
        },
        "dateuploaded": {
          "type": "string"
        },
        "isfavorite": {
          "type": "boolean"
        },
        "license": {
          "type": "string"
        },
        "safety_level": {
          "type": "string"
        },
        "rotation": {
          "type": "string"
        },
        "originalsecret": {
          "type": "string"
        },
        "owner": {
          "$ref": "#/definitions/Owner"
        },
        "title": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "description": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "visibility": {
          "type": "object",
          "properties": {
            "ispublic": {
              "type": "boolean"
            },
            "isfriend": {
              "type": "boolean"
            },
            "isfamily": {
              "type": "boolean"
            }
          }
        },
        "dates": {
          "type": "object",
          "properties": {
            "posted": {
              "type": "string"
            },
            "taken": {
              "type": "string"
            },
            "takengranularity": {
              "type": "string"
            },
            "takenunknown": {
              "type": "boolean"
            },
            "lastupdate": {
              "type": "string"
            }
          }
        },
        "permissions": {
          "type": "object",
          "properties": {
            "permcomment": {
              "type": "string"
            },
            "permaddmeta": {
              "type": "string"
            }
          }
        },
        "views": {
          "type": "string"
        },
        "editability": {
          "type": "object",
          "properties": {
            "cancomment": {
              "type": "boolean"
            },
            "canaddmeta": {
              "type": "boolean"
            }
          }
        },
        "publiceditability": {
          "type": "object",
          "properties": {
            "cancomment": {
              "type": "boolean"
            },
            "canaddmeta": {
              "type": "boolean"
            }
          }
        },
        "usage": {
          "type": "object",
          "properties": {
            "candownload": {
              "type": "boolean"
            },
            "canblog": {
              "type": "boolean"
            },
            "canprint": {
              "type": "boolean"
            },
            "canshare": {
              "type": "boolean"
            }
          }
        },
        "comments": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "notes": {
          "type": "object",
          "properties": {
            "note": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Note"
              }
            }
          }
        },
        "people": {
          "type": "object",
          "properties": {
            "haspeople": {
              "type": "boolean"
            }
          }
        },
        "tags": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Tag"
              }
            }
          }
        },
        "urls": {
          "type": "object",
          "properties": {
            "url": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/URL"
              }
            }
          }
        },
        "safe": {
          "type": "boolean"
        },
        "media": {
          "type": "string"
        }
      }
    },
    "PhotoURLs": {
      "type": "object",
      "properties": {
        "h": {
          "type": "string"
        },
        "l": {
          "type": "string"
        },
        "s": {
          "type": "string"
        },
        "t": {
          "type": "string"
        }
      }
    },
    "Stat": {
      "type": "string"
    },
    "Tag": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "author": {
          "type": "string"
        },
        "authorname": {
          "type": "string"
        },
        "raw": {
          "type": "string"
        },
        "_content": {
          "type": "string"
        },
        "machine_tag": {
          "type": "boolean"
        }
      }
    },
    "Topic": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "subject": {
          "type": "string"
        },
        "message": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "author": {
          "type": "string"
        },
        "authorname": {
          "type": "string"
        },
        "author_path_alias": {
          "type": "string"
        },
        "author_is_deleted": {
          "type": "boolean"
        },
        "is_pro": {
          "type": "boolean"
        },
        "role": {
          "type": "string"
        },
        "iconserver": {
          "type": "string"
        },
        "iconfarm": {
          "type": "string"
        },
        "count_replies": {
          "type": "integer"
        },
        "can_edit": {
          "type": "boolean"
        },
        "can_delete": {
          "type": "boolean"
        },
        "can_reply": {
          "type": "boolean"
        },
        "is_sticky": {
          "type": "boolean"
        },
        "is_locked": {
          "type": "boolean"
        },
        "datecreate": {
          "type": "string"
        },
        "datelastpost": {
          "type": "string"
        },
        "last_reply": {
          "type": "string"
        },
        "lastedit": {
          "type": "string"
        }
      }
    },
    "TopicReply": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "message": {
          "type": "object",
          "properties": {
            "_content": {
              "type": "string"
            }
          }
        },
        "author": {
          "type": "string"
        },
        "authorname": {
          "type": "string"
        },
        "author_path_alias": {
          "type": "string"
        },
        "author_is_deleted": {
          "type": "boolean"
        },
        "is_pro": {
          "type": "boolean"
        },
        "iconserver": {
          "type": "string"
        },
        "iconfarm": {
          "type": "string"
        },
        "can_edit": {
          "type": "boolean"
        },
        "can_delete": {
          "type": "boolean"
        },
        "datecreate": {
          "type": "string"
        },
        "lastedit": {
          "type": "string"
        }
      }
    },
    "URL": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "_content": {
          "type": "string"
        }
      }
    },
    "Album": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "primary": {
          "type": "string"
        },
        "secret": {
          "type": "string"
        },
        "server": {
          "type": "string"
        },
        "farm": {
          "type": "string"
        },
        "photos": {
          "type": "number"
        },
        "videos": {
          "type": "number"
        },
        "count_views": {
          "type": "number"
        },
        "count_comments": {
          "type": "number"
        },
        "can_comment": {
          "type": "boolean"
        },
        "date_create": {
          "type": "number"
        },
        "date_update": {
          "type": "number"
        },
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        }
      }
    },
    "Size": {
      "type": "object",
      "properties": {
        "label": {
          "type": "string"
        },
        "width": {
          "type": "number"
        },
        "height": {
          "type": "number"
        },
        "source": {
          "type": "string"
        },
        "url": {
          "type": "string"
        },
        "media": {
          "type": "string"
        }
      }
    }
  }
}

},{}],20:[function(require,module,exports){
module.exports = require('./dist/schema.json');

},{"./dist/schema.json":19}],21:[function(require,module,exports){
(function (global){
/*! Native Promise Only
    v0.8.1 (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
*/

(function UMD(name,context,definition){
	// special form of UMD for polyfilling across evironments
	context[name] = context[name] || definition();
	if (typeof module != "undefined" && module.exports) { module.exports = context[name]; }
	else if (typeof define == "function" && define.amd) { define(function $AMD$(){ return context[name]; }); }
})("Promise",typeof global != "undefined" ? global : this,function DEF(){
	/*jshint validthis:true */
	"use strict";

	var builtInProp, cycle, scheduling_queue,
		ToString = Object.prototype.toString,
		timer = (typeof setImmediate != "undefined") ?
			function timer(fn) { return setImmediate(fn); } :
			setTimeout
	;

	// dammit, IE8.
	try {
		Object.defineProperty({},"x",{});
		builtInProp = function builtInProp(obj,name,val,config) {
			return Object.defineProperty(obj,name,{
				value: val,
				writable: true,
				configurable: config !== false
			});
		};
	}
	catch (err) {
		builtInProp = function builtInProp(obj,name,val) {
			obj[name] = val;
			return obj;
		};
	}

	// Note: using a queue instead of array for efficiency
	scheduling_queue = (function Queue() {
		var first, last, item;

		function Item(fn,self) {
			this.fn = fn;
			this.self = self;
			this.next = void 0;
		}

		return {
			add: function add(fn,self) {
				item = new Item(fn,self);
				if (last) {
					last.next = item;
				}
				else {
					first = item;
				}
				last = item;
				item = void 0;
			},
			drain: function drain() {
				var f = first;
				first = last = cycle = void 0;

				while (f) {
					f.fn.call(f.self);
					f = f.next;
				}
			}
		};
	})();

	function schedule(fn,self) {
		scheduling_queue.add(fn,self);
		if (!cycle) {
			cycle = timer(scheduling_queue.drain);
		}
	}

	// promise duck typing
	function isThenable(o) {
		var _then, o_type = typeof o;

		if (o != null &&
			(
				o_type == "object" || o_type == "function"
			)
		) {
			_then = o.then;
		}
		return typeof _then == "function" ? _then : false;
	}

	function notify() {
		for (var i=0; i<this.chain.length; i++) {
			notifyIsolated(
				this,
				(this.state === 1) ? this.chain[i].success : this.chain[i].failure,
				this.chain[i]
			);
		}
		this.chain.length = 0;
	}

	// NOTE: This is a separate function to isolate
	// the `try..catch` so that other code can be
	// optimized better
	function notifyIsolated(self,cb,chain) {
		var ret, _then;
		try {
			if (cb === false) {
				chain.reject(self.msg);
			}
			else {
				if (cb === true) {
					ret = self.msg;
				}
				else {
					ret = cb.call(void 0,self.msg);
				}

				if (ret === chain.promise) {
					chain.reject(TypeError("Promise-chain cycle"));
				}
				else if (_then = isThenable(ret)) {
					_then.call(ret,chain.resolve,chain.reject);
				}
				else {
					chain.resolve(ret);
				}
			}
		}
		catch (err) {
			chain.reject(err);
		}
	}

	function resolve(msg) {
		var _then, self = this;

		// already triggered?
		if (self.triggered) { return; }

		self.triggered = true;

		// unwrap
		if (self.def) {
			self = self.def;
		}

		try {
			if (_then = isThenable(msg)) {
				schedule(function(){
					var def_wrapper = new MakeDefWrapper(self);
					try {
						_then.call(msg,
							function $resolve$(){ resolve.apply(def_wrapper,arguments); },
							function $reject$(){ reject.apply(def_wrapper,arguments); }
						);
					}
					catch (err) {
						reject.call(def_wrapper,err);
					}
				})
			}
			else {
				self.msg = msg;
				self.state = 1;
				if (self.chain.length > 0) {
					schedule(notify,self);
				}
			}
		}
		catch (err) {
			reject.call(new MakeDefWrapper(self),err);
		}
	}

	function reject(msg) {
		var self = this;

		// already triggered?
		if (self.triggered) { return; }

		self.triggered = true;

		// unwrap
		if (self.def) {
			self = self.def;
		}

		self.msg = msg;
		self.state = 2;
		if (self.chain.length > 0) {
			schedule(notify,self);
		}
	}

	function iteratePromises(Constructor,arr,resolver,rejecter) {
		for (var idx=0; idx<arr.length; idx++) {
			(function IIFE(idx){
				Constructor.resolve(arr[idx])
				.then(
					function $resolver$(msg){
						resolver(idx,msg);
					},
					rejecter
				);
			})(idx);
		}
	}

	function MakeDefWrapper(self) {
		this.def = self;
		this.triggered = false;
	}

	function MakeDef(self) {
		this.promise = self;
		this.state = 0;
		this.triggered = false;
		this.chain = [];
		this.msg = void 0;
	}

	function Promise(executor) {
		if (typeof executor != "function") {
			throw TypeError("Not a function");
		}

		if (this.__NPO__ !== 0) {
			throw TypeError("Not a promise");
		}

		// instance shadowing the inherited "brand"
		// to signal an already "initialized" promise
		this.__NPO__ = 1;

		var def = new MakeDef(this);

		this["then"] = function then(success,failure) {
			var o = {
				success: typeof success == "function" ? success : true,
				failure: typeof failure == "function" ? failure : false
			};
			// Note: `then(..)` itself can be borrowed to be used against
			// a different promise constructor for making the chained promise,
			// by substituting a different `this` binding.
			o.promise = new this.constructor(function extractChain(resolve,reject) {
				if (typeof resolve != "function" || typeof reject != "function") {
					throw TypeError("Not a function");
				}

				o.resolve = resolve;
				o.reject = reject;
			});
			def.chain.push(o);

			if (def.state !== 0) {
				schedule(notify,def);
			}

			return o.promise;
		};
		this["catch"] = function $catch$(failure) {
			return this.then(void 0,failure);
		};

		try {
			executor.call(
				void 0,
				function publicResolve(msg){
					resolve.call(def,msg);
				},
				function publicReject(msg) {
					reject.call(def,msg);
				}
			);
		}
		catch (err) {
			reject.call(def,err);
		}
	}

	var PromisePrototype = builtInProp({},"constructor",Promise,
		/*configurable=*/false
	);

	// Note: Android 4 cannot use `Object.defineProperty(..)` here
	Promise.prototype = PromisePrototype;

	// built-in "brand" to signal an "uninitialized" promise
	builtInProp(PromisePrototype,"__NPO__",0,
		/*configurable=*/false
	);

	builtInProp(Promise,"resolve",function Promise$resolve(msg) {
		var Constructor = this;

		// spec mandated checks
		// note: best "isPromise" check that's practical for now
		if (msg && typeof msg == "object" && msg.__NPO__ === 1) {
			return msg;
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			resolve(msg);
		});
	});

	builtInProp(Promise,"reject",function Promise$reject(msg) {
		return new this(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			reject(msg);
		});
	});

	builtInProp(Promise,"all",function Promise$all(arr) {
		var Constructor = this;

		// spec mandated checks
		if (ToString.call(arr) != "[object Array]") {
			return Constructor.reject(TypeError("Not an array"));
		}
		if (arr.length === 0) {
			return Constructor.resolve([]);
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			var len = arr.length, msgs = Array(len), count = 0;

			iteratePromises(Constructor,arr,function resolver(idx,msg) {
				msgs[idx] = msg;
				if (++count === len) {
					resolve(msgs);
				}
			},reject);
		});
	});

	builtInProp(Promise,"race",function Promise$race(arr) {
		var Constructor = this;

		// spec mandated checks
		if (ToString.call(arr) != "[object Array]") {
			return Constructor.reject(TypeError("Not an array"));
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			iteratePromises(Constructor,arr,function resolver(idx,msg){
				resolve(msg);
			},reject);
		});
	});

	return Promise;
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],22:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Emitter = require('emitter');
var reduce = require('reduce');
var requestBase = require('./request-base');
var isObject = require('./is-object');

/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  root = this;
}

/**
 * Noop.
 */

function noop(){};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Expose `request`.
 */

var request = module.exports = require('./request').bind(null, Request);

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  return false;
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    if (null != obj[key]) {
      pushEncodedKeyValuePair(pairs, key, obj[key]);
        }
      }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (Array.isArray(val)) {
    return val.forEach(function(v) {
      pushEncodedKeyValuePair(pairs, key, v);
    });
  }
  pairs.push(encodeURIComponent(key)
    + '=' + encodeURIComponent(val));
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var parts;
  var pair;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    parts = pair.split('=');
    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  return /[\/+]json\b/.test(mime);
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return reduce(str.split(/ *; */), function(obj, str){
    var parts = str.split(/ *= */)
      , key = parts.shift()
      , val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  this.setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this.setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this.parseBody(this.text ? this.text : this.xhr.response)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype.setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype.parseBody = function(str){
  var parse = request.parse[this.type];
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype.setStatusProperties = function(status){
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }

  var type = status / 100 | 0;

  // status / class
  this.status = this.statusCode = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;
      // issue #876: return the http status code if the response parsing fails
      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;
      return self.callback(err);
    }

    self.emit('response', res);

    if (err) {
      return self.callback(err, res);
    }

    if (res.status >= 200 && res.status < 300) {
      return self.callback(err, res);
    }

    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
    new_err.original = err;
    new_err.response = res;
    new_err.status = res.status;

    self.callback(new_err, res);
  });
}

/**
 * Mixin `Emitter` and `requestBase`.
 */

Emitter(Request.prototype);
for (var key in requestBase) {
  Request.prototype[key] = requestBase[key];
}

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */

Request.prototype.abort = function(){
  if (this.aborted) return;
  this.aborted = true;
  this.xhr.abort();
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set responseType to `val`. Presently valid responseTypes are 'blob' and 
 * 'arraybuffer'.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (!options) {
    options = {
      type: 'basic'
    }
  }

  switch (options.type) {
    case 'basic':
      var str = btoa(user + ':' + pass);
      this.set('Authorization', 'Basic ' + str);
    break;

    case 'auto':
      this.username = user;
      this.password = pass;
    break;
  }
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  this._getFormData().append(field, file, filename || file.name);
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
  *      request.post('/user')
  *        .send('name=tobi')
  *        .send('species=ferret')
  *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.send = function(data){
  var obj = isObject(data);
  var type = this._header['content-type'];

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj || isHost(data)) return this;
  if (!type) this.type('json');
  return this;
};

/**
 * @deprecated
 */
Response.prototype.parse = function serialize(fn){
  if (root.console) {
    console.warn("Client-side parse() method has been renamed to serialize(). This method is not compatible with superagent v2.0");
  }
  this.serialize(fn);
  return this;
};

Response.prototype.serialize = function serialize(fn){
  this._parser = fn;
  return this;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype.timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

Request.prototype.withCredentials = function(){
  this._withCredentials = true;
  return this;
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var query = this._query.join('&');
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (0 == status) {
      if (self.timedout) return self.timeoutError();
      if (self.aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(e){
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = 'download';
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    xhr.onprogress = handleProgress;
  }
  try {
    if (xhr.upload && this.hasListeners('progress')) {
      xhr.upload.onprogress = handleProgress;
    }
  } catch(e) {
    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
    // Reported here:
    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.timedout = true;
      self.abort();
    }, timeout);
  }

  // querystring
  if (query) {
    query = request.serializeObject(query);
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }

  // initiate request
  if (this.username && this.password) {
    xhr.open(this.method, this.url, true, this.username, this.password);
  } else {
    xhr.open(this.method, this.url, true);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._parser || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};


/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

function del(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./is-object":23,"./request":25,"./request-base":24,"emitter":26,"reduce":27}],23:[function(require,module,exports){
/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null != obj && 'object' == typeof obj;
}

module.exports = isObject;

},{}],24:[function(require,module,exports){
/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = require('./is-object');

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

exports.clearTimeout = function _clearTimeout(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Force given parser
 *
 * Sets the body parser no matter type.
 *
 * @param {Function}
 * @api public
 */

exports.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

exports.timeout = function timeout(ms){
  this._timeout = ms;
  return this;
};

/**
 * Faux promise support
 *
 * @param {Function} fulfill
 * @param {Function} reject
 * @return {Request}
 */

exports.then = function then(fulfill, reject) {
  return this.end(function(err, res) {
    err ? reject(err) : fulfill(res);
  });
}

/**
 * Allow for extension
 */

exports.use = function use(fn) {
  fn(this);
  return this;
}


/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

exports.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

exports.getHeader = exports.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

exports.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
exports.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val` for "multipart/form-data"
 * request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 * ```
 *
 * @param {String} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
exports.field = function(name, val) {
  this._getFormData().append(name, val);
  return this;
};

},{"./is-object":23}],25:[function(require,module,exports){
// The node and browser modules expose versions of this with the
// appropriate constructor function bound as first argument
/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(RequestConstructor, method, url) {
  // callback
  if ('function' == typeof url) {
    return new RequestConstructor('GET', method).end(url);
  }

  // url first
  if (2 == arguments.length) {
    return new RequestConstructor('GET', method);
  }

  return new RequestConstructor(method, url);
}

module.exports = request;

},{}],26:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],27:[function(require,module,exports){

/**
 * Reduce `arr` with `fn`.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Mixed} initial
 *
 * TODO: combatible error handling?
 */

module.exports = function(arr, fn, initial){  
  var idx = 0;
  var len = arr.length;
  var curr = arguments.length == 3
    ? initial
    : arr[idx++];

  while (idx < len) {
    curr = fn.call(null, curr, arr[idx], ++idx, arr);
  }
  
  return curr;
};
},{}],28:[function(require,module,exports){
var JsSHA = require('../vendor/jssha.js');

module.exports = {
	createHash: function (type) {
		if (type === 'sha1') {
			var ret = new JsSHA('SHA-1', 'TEXT'),
			    oldUpdate = ret.update;

			ret.digest = function (type) {
				if (type === 'hex') {
					return ret.getHash('HEX');
				}
			};

			ret.update = function (str) {
				oldUpdate.call(ret, str);

				return this;
			};

			return ret;
		}
	},

	createHmac: function (type, key) {
		if (type === 'sha1') {
			var ret = new JsSHA('SHA-1', 'TEXT'),
			    oldUpdate = ret.update;

			ret.digest = function (type) {
				if (type === 'base64') {
					return ret.getHMAC('B64');
				}
			};

			ret.update = function (str) {
				oldUpdate.call(ret, str);

				return this;
			};

			ret.setHMACKey(key, 'TEXT');

			return ret;
		}
	}
};

},{"../vendor/jssha.js":30}],29:[function(require,module,exports){
module.exports = require('crypto');

},{"crypto":15}],30:[function(require,module,exports){
/*
 A JavaScript implementation of the SHA family of hashes, as
 defined in FIPS PUB 180-2 as well as the corresponding HMAC implementation
 as defined in FIPS PUB 198a

 Copyright Brian Turek 2008-2015
 Distributed under the terms of the BSD license License
 See http://caligatio.github.com/jsSHA/ for more information

 Several functions taken from Paul Johnston
*/
(function(E){function t(e,a,c){var g=0,b=[],d=0,f,k,l,h,m,w,n,q=!1,r=!1,p=[],t=[],v,u=!1;c=c||{};f=c.encoding||"UTF8";v=c.numRounds||1;l=y(a,f);if(v!==parseInt(v,10)||1>v)throw Error("numRounds must a integer >= 1");if("SHA-1"===e)m=512,w=z,n=F,h=160;else throw Error("Chosen SHA variant is not supported");k=x(e);this.setHMACKey=function(a,b,d){var c;if(!0===r)throw Error("HMAC key already set");if(!0===q)throw Error("Cannot set HMAC key after finalizing hash");if(!0===u)throw Error("Cannot set HMAC key after calling update");
f=(d||{}).encoding||"UTF8";b=y(b,f)(a);a=b.binLen;b=b.value;c=m>>>3;d=c/4-1;if(c<a/8){for(b=n(b,a,0,x(e));b.length<=d;)b.push(0);b[d]&=4294967040}else if(c>a/8){for(;b.length<=d;)b.push(0);b[d]&=4294967040}for(a=0;a<=d;a+=1)p[a]=b[a]^909522486,t[a]=b[a]^1549556828;k=w(p,k);g=m;r=!0};this.update=function(a){var e,c,f,h=0,n=m>>>5;e=l(a,b,d);a=e.binLen;c=e.value;e=a>>>5;for(f=0;f<e;f+=n)h+m<=a&&(k=w(c.slice(f,f+n),k),h+=m);g+=h;b=c.slice(h>>>5);d=a%m;u=!0};this.getHash=function(a,c){var f,l,m;if(!0===
r)throw Error("Cannot call getHash after setting HMAC key");m=A(c);switch(a){case "HEX":f=function(a){return B(a,m)};break;case "B64":f=function(a){return C(a,m)};break;case "BYTES":f=D;break;default:throw Error("format must be HEX, B64, or BYTES");}if(!1===q)for(k=n(b,d,g,k),l=1;l<v;l+=1)k=n(k,h,0,x(e));q=!0;return f(k)};this.getHMAC=function(a,c){var f,l,p;if(!1===r)throw Error("Cannot call getHMAC without first setting HMAC key");p=A(c);switch(a){case "HEX":f=function(a){return B(a,p)};break;case "B64":f=
function(a){return C(a,p)};break;case "BYTES":f=D;break;default:throw Error("outputFormat must be HEX, B64, or BYTES");}!1===q&&(l=n(b,d,g,k),k=w(t,x(e)),k=n(l,h,m,k));q=!0;return f(k)}}function G(e,a,c){var g=e.length,b,d,f,k,l;a=a||[0];c=c||0;l=c>>>3;if(0!==g%2)throw Error("String of HEX type must be in byte increments");for(b=0;b<g;b+=2){d=parseInt(e.substr(b,2),16);if(isNaN(d))throw Error("String of HEX type contains invalid characters");k=(b>>>1)+l;for(f=k>>>2;a.length<=f;)a.push(0);a[f]|=d<<
8*(3-k%4)}return{value:a,binLen:4*g+c}}function H(e,a,c){var g=[],b,d,f,k,g=a||[0];c=c||0;d=c>>>3;for(b=0;b<e.length;b+=1)a=e.charCodeAt(b),k=b+d,f=k>>>2,g.length<=f&&g.push(0),g[f]|=a<<8*(3-k%4);return{value:g,binLen:8*e.length+c}}function I(e,a,c){var g=[],b=0,d,f,k,l,h,m,g=a||[0];c=c||0;a=c>>>3;if(-1===e.search(/^[a-zA-Z0-9=+\/]+$/))throw Error("Invalid character in base-64 string");f=e.indexOf("=");e=e.replace(/\=/g,"");if(-1!==f&&f<e.length)throw Error("Invalid '=' found in base-64 string");
for(f=0;f<e.length;f+=4){h=e.substr(f,4);for(k=l=0;k<h.length;k+=1)d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(h[k]),l|=d<<18-6*k;for(k=0;k<h.length-1;k+=1){m=b+a;for(d=m>>>2;g.length<=d;)g.push(0);g[d]|=(l>>>16-8*k&255)<<8*(3-m%4);b+=1}}return{value:g,binLen:8*b+c}}function B(e,a){var c="",g=4*e.length,b,d;for(b=0;b<g;b+=1)d=e[b>>>2]>>>8*(3-b%4),c+="0123456789abcdef".charAt(d>>>4&15)+"0123456789abcdef".charAt(d&15);return a.outputUpper?c.toUpperCase():c}function C(e,
a){var c="",g=4*e.length,b,d,f;for(b=0;b<g;b+=3)for(f=b+1>>>2,d=e.length<=f?0:e[f],f=b+2>>>2,f=e.length<=f?0:e[f],f=(e[b>>>2]>>>8*(3-b%4)&255)<<16|(d>>>8*(3-(b+1)%4)&255)<<8|f>>>8*(3-(b+2)%4)&255,d=0;4>d;d+=1)8*b+6*d<=32*e.length?c+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(f>>>6*(3-d)&63):c+=a.b64Pad;return c}function D(e){var a="",c=4*e.length,g,b;for(g=0;g<c;g+=1)b=e[g>>>2]>>>8*(3-g%4)&255,a+=String.fromCharCode(b);return a}function A(e){var a={outputUpper:!1,b64Pad:"="};
e=e||{};a.outputUpper=e.outputUpper||!1;!0===e.hasOwnProperty("b64Pad")&&(a.b64Pad=e.b64Pad);if("boolean"!==typeof a.outputUpper)throw Error("Invalid outputUpper formatting option");if("string"!==typeof a.b64Pad)throw Error("Invalid b64Pad formatting option");return a}function y(e,a){var c;switch(a){case "UTF8":case "UTF16BE":case "UTF16LE":break;default:throw Error("encoding must be UTF8, UTF16BE, or UTF16LE");}switch(e){case "HEX":c=G;break;case "TEXT":c=function(e,b,d){var f=[],c=[],l=0,h,m,p,
n,q,f=b||[0];b=d||0;p=b>>>3;if("UTF8"===a)for(h=0;h<e.length;h+=1)for(d=e.charCodeAt(h),c=[],128>d?c.push(d):2048>d?(c.push(192|d>>>6),c.push(128|d&63)):55296>d||57344<=d?c.push(224|d>>>12,128|d>>>6&63,128|d&63):(h+=1,d=65536+((d&1023)<<10|e.charCodeAt(h)&1023),c.push(240|d>>>18,128|d>>>12&63,128|d>>>6&63,128|d&63)),m=0;m<c.length;m+=1){q=l+p;for(n=q>>>2;f.length<=n;)f.push(0);f[n]|=c[m]<<8*(3-q%4);l+=1}else if("UTF16BE"===a||"UTF16LE"===a)for(h=0;h<e.length;h+=1){d=e.charCodeAt(h);"UTF16LE"===a&&
(m=d&255,d=m<<8|d>>>8);q=l+p;for(n=q>>>2;f.length<=n;)f.push(0);f[n]|=d<<8*(2-q%4);l+=2}return{value:f,binLen:8*l+b}};break;case "B64":c=I;break;case "BYTES":c=H;break;default:throw Error("format must be HEX, TEXT, B64, or BYTES");}return c}function r(e,a){return e<<a|e>>>32-a}function p(e,a){var c=(e&65535)+(a&65535);return((e>>>16)+(a>>>16)+(c>>>16)&65535)<<16|c&65535}function u(e,a,c,g,b){var d=(e&65535)+(a&65535)+(c&65535)+(g&65535)+(b&65535);return((e>>>16)+(a>>>16)+(c>>>16)+(g>>>16)+(b>>>16)+
(d>>>16)&65535)<<16|d&65535}function x(e){if("SHA-1"===e)e=[1732584193,4023233417,2562383102,271733878,3285377520];else throw Error("No SHA variants supported");return e}function z(e,a){var c=[],g,b,d,f,k,l,h;g=a[0];b=a[1];d=a[2];f=a[3];k=a[4];for(h=0;80>h;h+=1)c[h]=16>h?e[h]:r(c[h-3]^c[h-8]^c[h-14]^c[h-16],1),l=20>h?u(r(g,5),b&d^~b&f,k,1518500249,c[h]):40>h?u(r(g,5),b^d^f,k,1859775393,c[h]):60>h?u(r(g,5),b&d^b&f^d&f,k,2400959708,c[h]):u(r(g,5),b^d^f,k,3395469782,c[h]),k=f,f=d,d=r(b,30),b=g,g=l;a[0]=
p(g,a[0]);a[1]=p(b,a[1]);a[2]=p(d,a[2]);a[3]=p(f,a[3]);a[4]=p(k,a[4]);return a}function F(e,a,c,g){var b;for(b=(a+65>>>9<<4)+15;e.length<=b;)e.push(0);e[a>>>5]|=128<<24-a%32;e[b]=a+c;c=e.length;for(a=0;a<c;a+=16)g=z(e.slice(a,a+16),g);return g}"function"===typeof define&&define.amd?define(function(){return t}):"undefined"!==typeof exports?"undefined"!==typeof module&&module.exports?module.exports=exports=t:exports=t:E.jsSHA=t})(this);

},{}],"flickr-sdk":[function(require,module,exports){
// Copyright 2016 Yahoo Inc.
// Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.

var FlickrTransport = require('./lib/flickr-transport.js');
var findDefinition = require('./lib/find-definition.js');

/**
 * An instance of this object is returned when calling request() on an instance
 * of the FlcikrSDK. On its prototype are all the data types and their children
 * namespaces for making API calls on Flickr Data.
 * @constructor
 * @name FlickrRequest
 * @param {object} sdk - This is the instance of the {@link FlickrSDK} holding config and transport
 */
var FlickrRequest = function (sdk, accessToken, accessTokenSecret) {
	this.sdk = sdk;
	this.auth = {
		accessToken: accessToken,
		accessTokenSecret: accessTokenSecret
	};
};

/**
 * Accepts API config and returns an instance of {@link FlickrRequest}
 * @constructor
 * @name FlickrSDK
 * @param {object} config - API authentication details
 * @param {string} config.apiKey - Unique API key for your app
 * @param {string} config.apiSecret - Your API secret for signing calls
 * @param {string=} config.accessToken - A user's access token for use with your app
 * @param {string=} config.accessTokenSecret - A user's secret for signing calls
 * @param {string=} config.host - Optional host override useful for testing dev hosts
 * @param {string=} config.basePath - Optional basePath override useful for testing dev hosts
 * @param {string=} config.scheme - Optional scheme override useful for testing dev hosts or proxies
 * @param {object} options - Additional initialization params
 * @param {object} options.logger - Object with a log method for handling messages
 * @returns {object} FlickrRequest - Object with a bunch of things to call methods on
 */
var FlickrSDK = function (config, options) {

	// Store config on the SDK
	this.config = config || {};
	this.transport = new FlickrTransport(config, options);
	this.findDefinition = findDefinition;

	// Each time it's called return a new instance
	return {
		request: (function (accessToken, accessTokenSecret) {
			return new FlickrRequest(this, accessToken, accessTokenSecret);
		}).bind(this)
	};

};

/**
 * Allow the passing in of a superagent request plugin, many can be
 * added in a chain.
 * @function plugin
 * @memberof! FlickrRequest#
 * @param {function} plugin - Superagent request plugin (https://github.com/visionmedia/superagent#plugins)
 * @returns {object} the FlickrRequest instance to make calls against
 */
FlickrRequest.prototype.plugin = function (plugin) {
	this.sdk.transport.plugins.push(plugin);
	return this;
};

/**
 * Namespaces
 */
FlickrRequest.prototype.validate = require('./lib/sdk/validate');
FlickrRequest.prototype.media = require('./lib/sdk/media');
FlickrRequest.prototype.groups = require('./lib/sdk/groups');
FlickrRequest.prototype.albums = require('./lib/sdk/albums');
FlickrRequest.prototype.galleries = require('./lib/sdk/galleries');
FlickrRequest.prototype.people = require('./lib/sdk/people');

/* not a namespace so much as a wrapper function for the oauthflow */
FlickrRequest.prototype.authentication = require('./lib/sdk/auth');

/**
 * Expose it
 */
module.exports = FlickrSDK;

},{"./lib/find-definition.js":1,"./lib/flickr-transport.js":2,"./lib/sdk/albums":6,"./lib/sdk/auth":7,"./lib/sdk/galleries":8,"./lib/sdk/groups":9,"./lib/sdk/media":10,"./lib/sdk/people":11,"./lib/sdk/validate":12}]},{},[]);
